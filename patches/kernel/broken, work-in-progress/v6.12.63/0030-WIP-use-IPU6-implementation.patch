From fa683c43d5f2f4aafd59dfff0abe2639e1df623f Mon Sep 17 00:00:00 2001
From: ruslanbay <67730802+ruslanbay@users.noreply.github.com>
Date: Mon, 22 Dec 2025 21:19:08 +0100
Subject: [PATCH] [WIP] use IPU6 implementation

https://github.com/intel/ipu6-drivers/blob/9766e218112f4173be9b0f06dfae27cb40c54f40/drivers/media/pci/intel
---
 drivers/media/pci/intel/ipu-bus.h             |   1 +
 drivers/media/pci/intel/ipu-fw-isys.h         |   8 -
 .../media/pci/intel/ipu-isys-csi2-be-soc.c    | 213 ++++---
 drivers/media/pci/intel/ipu-isys-csi2-be.c    |  41 +-
 drivers/media/pci/intel/ipu-isys-csi2-be.h    |  17 +-
 drivers/media/pci/intel/ipu-isys-csi2.c       | 327 ++---------
 drivers/media/pci/intel/ipu-isys-csi2.h       |  21 +-
 drivers/media/pci/intel/ipu-isys-queue.c      |   6 +-
 drivers/media/pci/intel/ipu-isys-subdev.c     |  74 +--
 drivers/media/pci/intel/ipu-isys-subdev.h     |  27 +-
 drivers/media/pci/intel/ipu-isys-tpg.c        |   3 +-
 drivers/media/pci/intel/ipu-isys-video.c      | 162 +++--
 drivers/media/pci/intel/ipu-isys-video.h      |  45 +-
 drivers/media/pci/intel/ipu-isys.c            | 426 ++++++--------
 drivers/media/pci/intel/ipu-isys.h            |  64 +-
 drivers/media/pci/intel/ipu-mmu.c             | 551 ++++++------------
 drivers/media/pci/intel/ipu-mmu.h             |  19 +-
 drivers/media/pci/intel/ipu.c                 |   1 -
 .../intel/ipu4/ipu-platform-isys-csi2-reg.h   |  28 +-
 drivers/media/pci/intel/ipu4/ipu4-isys-isa.c  |  16 +-
 drivers/media/pci/intel/ipu4/ipu4-isys.c      |  15 -
 .../media/pci/intel/ipu4/ipu4p-isys-csi2.c    | 110 +---
 22 files changed, 869 insertions(+), 1306 deletions(-)

diff --git a/drivers/media/pci/intel/ipu-bus.h b/drivers/media/pci/intel/ipu-bus.h
index 5d47d03b06c4..ab6cafc535f4 100644
--- a/drivers/media/pci/intel/ipu-bus.h
+++ b/drivers/media/pci/intel/ipu-bus.h
@@ -23,6 +23,7 @@ struct ipu_bus_device {
 	struct ipu_bus_driver *adrv;
 	struct device *iommu;
 	struct iommu_device iommu_dev;
+	struct ipu_mmu *mmu;
 	struct ipu_device *isp;
 	struct ipu_subsystem_trace_config *trace_cfg;
 	struct ipu_buttress_ctrl *ctrl;
diff --git a/drivers/media/pci/intel/ipu-fw-isys.h b/drivers/media/pci/intel/ipu-fw-isys.h
index 2853e1e1c9d9..537d6a06a3f3 100644
--- a/drivers/media/pci/intel/ipu-fw-isys.h
+++ b/drivers/media/pci/intel/ipu-fw-isys.h
@@ -148,7 +148,6 @@ enum ipu_fw_isys_stream_source {
 	N_IPU_FW_ISYS_STREAM_SRC
 };
 
-#if !defined(CONFIG_VIDEO_INTEL_IPU4) && !defined(CONFIG_VIDEO_INTEL_IPU4P)
 enum ipu_fw_isys_sensor_type {
 	/* non-snoopable to PSYS */
 	IPU_FW_ISYS_VC1_SENSOR_DATA	= 0,
@@ -191,7 +190,6 @@ enum ipu_fw_isys_sensor_info {
 	IPU_FW_ISYS_VC1_SENSOR_PDAF_START = IPU_FW_ISYS_SENSOR_PDAF_1,
 	IPU_FW_ISYS_VC1_SENSOR_PDAF_END = IPU_FW_ISYS_SENSOR_PDAF_2,
 };
-#endif
 
 #define IPU_FW_ISYS_STREAM_SRC_CSI2_PORT0 IPU_FW_ISYS_STREAM_SRC_PORT_0
 #define IPU_FW_ISYS_STREAM_SRC_CSI2_PORT1 IPU_FW_ISYS_STREAM_SRC_PORT_1
@@ -413,12 +411,10 @@ enum ipu_fw_isys_pin_type {
 	IPU_FW_ISYS_PIN_TYPE_HIST_STATS,
 	/* Used for the PAF FF */
 	IPU_FW_ISYS_PIN_TYPE_PAF_FF,
-#if !defined(CONFIG_VIDEO_INTEL_IPU4) && !defined(CONFIG_VIDEO_INTEL_IPU4P)
 	/* Captured through the SoC path
 	 * (2D mode where odd and even lines are handled separately)
 	 */
 	IPU_FW_ISYS_PIN_TYPE_RAW_DUAL_SOC,
-#endif
 	/* Keep always last and max value */
 	N_IPU_FW_ISYS_PIN_TYPE
 };
@@ -620,12 +616,10 @@ struct ipu_fw_isys_param_pin_abi {
  *		     (enum ipu_fw_isys_mipi_store_mode)
  * @bits_per_pix: native bits per pixel
  * @mapped_dt: actual data type from sensor
-#if !defined(CONFIG_VIDEO_INTEL_IPU4) && !defined(CONFIG_VIDEO_INTEL_IPU4P)
  * @crop_first_and_last_lines    Control whether to crop the
  *                              first and last line of the
  *                              input image. Crop done by HW
  *                              device.
-#endif
  */
 struct ipu_fw_isys_input_pin_info_abi {
 	struct ipu_fw_isys_resolution_abi input_res;
@@ -633,9 +627,7 @@ struct ipu_fw_isys_input_pin_info_abi {
 	u8 mipi_store_mode;
 	u8 bits_per_pix;
 	u8 mapped_dt;
-#if !defined(CONFIG_VIDEO_INTEL_IPU4) && !defined(CONFIG_VIDEO_INTEL_IPU4P)
 	u8 crop_first_and_last_lines;
-#endif
 };
 
 /**
diff --git a/drivers/media/pci/intel/ipu-isys-csi2-be-soc.c b/drivers/media/pci/intel/ipu-isys-csi2-be-soc.c
index 3fc1221781e5..756e51632eac 100644
--- a/drivers/media/pci/intel/ipu-isys-csi2-be-soc.c
+++ b/drivers/media/pci/intel/ipu-isys-csi2-be-soc.c
@@ -46,6 +46,38 @@ static const u32 csi2_be_soc_supported_codes_pad[] = {
 	0,
 };
 
+/*
+ * Raw bayer format pixel order MUST BE MAINTAINED in groups of four codes.
+ * Otherwise pixel order calculation below WILL BREAK!
+ */
+static const u32 csi2_be_soc_supported_raw_bayer_codes_pad[] = {
+	MEDIA_BUS_FMT_SBGGR12_1X12,
+	MEDIA_BUS_FMT_SGBRG12_1X12,
+	MEDIA_BUS_FMT_SGRBG12_1X12,
+	MEDIA_BUS_FMT_SRGGB12_1X12,
+	MEDIA_BUS_FMT_SBGGR10_1X10,
+	MEDIA_BUS_FMT_SGBRG10_1X10,
+	MEDIA_BUS_FMT_SGRBG10_1X10,
+	MEDIA_BUS_FMT_SRGGB10_1X10,
+	MEDIA_BUS_FMT_SBGGR8_1X8,
+	MEDIA_BUS_FMT_SGBRG8_1X8,
+	MEDIA_BUS_FMT_SGRBG8_1X8,
+	MEDIA_BUS_FMT_SRGGB8_1X8,
+	MEDIA_BUS_FMT_Y8_1X8,
+	0,
+};
+
+static int get_supported_code_index(u32 code)
+{
+	int i;
+
+	for (i = 0; csi2_be_soc_supported_raw_bayer_codes_pad[i]; i++) {
+		if (csi2_be_soc_supported_raw_bayer_codes_pad[i] == code)
+			return i;
+	}
+	return -EINVAL;
+}
+
 static const u32 *csi2_be_soc_supported_codes[NR_OF_CSI2_BE_SOC_PADS];
 
 static struct v4l2_subdev_internal_ops csi2_be_soc_sd_internal_ops = {
@@ -89,41 +121,27 @@ ipu_isys_csi2_be_soc_set_sel(struct v4l2_subdev *sd,
 	if (sel->target == V4L2_SEL_TGT_CROP &&
 	    pad->flags & MEDIA_PAD_FL_SOURCE &&
 	    asd->valid_tgts[sel->pad].crop) {
-		struct v4l2_rect *r;
-		unsigned int sink_pad = 0;
-		int i;
-
-		for (i = 0; i < asd->nstreams; i++) {
-			if (!(asd->route[i].flags &
-			      V4L2_SUBDEV_ROUTE_FL_ACTIVE))
-				continue;
-			if (asd->route[i].source == sel->pad) {
-				sink_pad = asd->route[i].sink;
-				break;
-			}
-		}
-
-		if (i == asd->nstreams) {
-			dev_dbg(&asd->isys->adev->dev, "No sink pad routed.\n");
-			return -EINVAL;
+		enum isys_subdev_prop_tgt tgt =
+		    IPU_ISYS_SUBDEV_PROP_TGT_SOURCE_CROP;
+		struct v4l2_mbus_framefmt *ffmt =
+			__ipu_isys_get_ffmt(sd, state, sel->pad, sel->which);
+
+		if (get_supported_code_index(ffmt->code) < 0) {
+			/* Non-bayer formats can't be odd lines cropped */
+			sel->r.left &= ~1;
+			sel->r.top &= ~1;
 		}
-		r = __ipu_isys_get_selection(sd, state, sel->target,
-					     sink_pad, sel->which);
 
-		/* Cropping is not supported by SoC BE.
-		 * Only horizontal padding is allowed.
-		 */
-		sel->r.top = r->top;
-		sel->r.left = r->left;
-		sel->r.width = clamp(sel->r.width, r->width,
+		sel->r.width = clamp(sel->r.width, IPU_ISYS_MIN_WIDTH,
 				     IPU_ISYS_MAX_WIDTH);
-		sel->r.height = r->height;
+
+		sel->r.height = clamp(sel->r.height, IPU_ISYS_MIN_HEIGHT,
+				      IPU_ISYS_MAX_HEIGHT);
 
 		*__ipu_isys_get_selection(sd, state, sel->target, sel->pad,
 					  sel->which) = sel->r;
 		ipu_isys_subdev_fmt_propagate(sd, state, NULL, &sel->r,
-					IPU_ISYS_SUBDEV_PROP_TGT_SOURCE_CROP,
-					sel->pad, sel->which);
+					      tgt, sel->pad, sel->which);
 		return 0;
 	}
 	return -EINVAL;
@@ -157,7 +175,6 @@ static void csi2_be_soc_set_ffmt(struct v4l2_subdev *sd,
 {
 	struct v4l2_mbus_framefmt *ffmt =
 		__ipu_isys_get_ffmt(sd, cfg, fmt->pad,
-				    fmt->stream,
 				    fmt->which);
 
 #if !defined(CONFIG_VIDEO_INTEL_IPU4) && !defined(CONFIG_VIDEO_INTEL_IPU4P)
@@ -187,7 +204,6 @@ static void csi2_be_soc_set_ffmt(struct v4l2_subdev *sd,
 		if (i != asd->nsinks)
 			sink_pad = i;
 		sink_ffmt = __ipu_isys_get_ffmt(sd, cfg, sink_pad,
-						fmt->stream,
 						fmt->which);
 		r = __ipu_isys_get_selection(sd, cfg, V4L2_SEL_TGT_CROP,
 					     fmt->pad, fmt->which);
@@ -220,20 +236,18 @@ static void csi2_be_soc_set_ffmt(struct v4l2_subdev *sd,
 
 void ipu_isys_csi2_be_soc_cleanup(struct ipu_isys_csi2_be_soc *csi2_be_soc)
 {
-	int i;
-
 	v4l2_device_unregister_subdev(&csi2_be_soc->asd.sd);
 	ipu_isys_subdev_cleanup(&csi2_be_soc->asd);
-	for (i = 0; i < NR_OF_CSI2_BE_SOC_STREAMS; i++)
-		ipu_isys_video_cleanup(&csi2_be_soc->av[i]);
+	v4l2_ctrl_handler_free(&csi2_be_soc->av.ctrl_handler);
+	ipu_isys_video_cleanup(&csi2_be_soc->av);
 }
 
 int ipu_isys_csi2_be_soc_init(struct ipu_isys_csi2_be_soc *csi2_be_soc,
-			      struct ipu_isys *isys)
+			      struct ipu_isys *isys, int index)
 {
 	struct v4l2_subdev_format fmt = {
 		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
-		.pad = CSI2_BE_SOC_PAD_SINK(0),
+		.pad = CSI2_BE_SOC_PAD_SINK,
 		.format = {
 			   .width = 4096,
 			   .height = 3072,
@@ -247,21 +261,14 @@ int ipu_isys_csi2_be_soc_init(struct ipu_isys_csi2_be_soc *csi2_be_soc,
 	rval = ipu_isys_subdev_init(&csi2_be_soc->asd,
 				    &csi2_be_soc_sd_ops, 0,
 				    NR_OF_CSI2_BE_SOC_PADS,
-				    NR_OF_CSI2_BE_SOC_STREAMS,
 				    NR_OF_CSI2_BE_SOC_SOURCE_PADS,
-				    NR_OF_CSI2_BE_SOC_SINK_PADS, 0);
+				    NR_OF_CSI2_BE_SOC_SINK_PADS, 0,
+				    CSI2_BE_SOC_PAD_SOURCE,
+				    CSI2_BE_SOC_PAD_SINK);
 	if (rval)
 		goto fail;
 
-	for (i = CSI2_BE_SOC_PAD_SINK(0); i < NR_OF_CSI2_BE_SOC_SINK_PADS; i++)
-		csi2_be_soc->asd.pad[i].flags = MEDIA_PAD_FL_SINK;
-
-	for (i = CSI2_BE_SOC_PAD_SOURCE(0);
-	     i < NR_OF_CSI2_BE_SOC_SOURCE_PADS + CSI2_BE_SOC_PAD_SOURCE(0);
-	     i++) {
-		csi2_be_soc->asd.pad[i].flags = MEDIA_PAD_FL_SOURCE;
-		csi2_be_soc->asd.valid_tgts[i].crop = true;
-	}
+	csi2_be_soc->asd.valid_tgts[CSI2_BE_SOC_PAD_SOURCE].crop = true;
 
 	for (i = 0; i < NR_OF_CSI2_BE_SOC_PADS; i++)
 		csi2_be_soc_supported_codes[i] =
@@ -271,21 +278,16 @@ int ipu_isys_csi2_be_soc_init(struct ipu_isys_csi2_be_soc *csi2_be_soc,
 	csi2_be_soc->asd.isl_mode = IPU_ISL_OFF;
 	csi2_be_soc->asd.set_ffmt = csi2_be_soc_set_ffmt;
 
-	for (i = CSI2_BE_SOC_PAD_SINK(0); i < NR_OF_CSI2_BE_SOC_SINK_PADS;
-	     i++) {
-		fmt.pad = CSI2_BE_SOC_PAD_SINK(i);
-		ipu_isys_subdev_set_ffmt(&csi2_be_soc->asd.sd, NULL, &fmt);
-	}
-
+	fmt.pad = CSI2_BE_SOC_PAD_SINK;
+	ipu_isys_subdev_set_ffmt(&csi2_be_soc->asd.sd, NULL, &fmt);
+	fmt.pad = CSI2_BE_SOC_PAD_SOURCE;
 	ipu_isys_subdev_set_ffmt(&csi2_be_soc->asd.sd, NULL, &fmt);
 	csi2_be_soc->asd.sd.internal_ops = &csi2_be_soc_sd_internal_ops;
 
 	snprintf(csi2_be_soc->asd.sd.name, sizeof(csi2_be_soc->asd.sd.name),
-		 IPU_ISYS_ENTITY_PREFIX " CSI2 BE SOC");
-
+		 IPU_ISYS_ENTITY_PREFIX " CSI2 BE SOC %d", index);
 	v4l2_set_subdevdata(&csi2_be_soc->asd.sd, &csi2_be_soc->asd);
 
-	mutex_lock(&csi2_be_soc->asd.mutex);
 	rval = v4l2_device_register_subdev(&isys->v4l2_dev,
 					   &csi2_be_soc->asd.sd);
 	if (rval) {
@@ -293,62 +295,55 @@ int ipu_isys_csi2_be_soc_init(struct ipu_isys_csi2_be_soc *csi2_be_soc,
 		goto fail;
 	}
 
-	/* create default route information */
-	for (i = 0; i < NR_OF_CSI2_BE_SOC_STREAMS; i++) {
-		csi2_be_soc->asd.route[i].sink = CSI2_BE_SOC_PAD_SINK(i);
-		csi2_be_soc->asd.route[i].source = CSI2_BE_SOC_PAD_SOURCE(i);
-		csi2_be_soc->asd.route[i].flags = 0;
+	snprintf(csi2_be_soc->av.vdev.name, sizeof(csi2_be_soc->av.vdev.name),
+		 IPU_ISYS_ENTITY_PREFIX " BE SOC capture %d", index);
+
+	/*
+	 * Pin type could be overwritten for YUV422 to I420 case, at
+	 * set_format phase
+	 */
+	csi2_be_soc->av.aq.css_pin_type = IPU_FW_ISYS_PIN_TYPE_RAW_SOC;
+	csi2_be_soc->av.isys = isys;
+	csi2_be_soc->av.pfmts = ipu_isys_pfmts_be_soc;
+	csi2_be_soc->av.try_fmt_vid_mplane =
+		ipu_isys_video_try_fmt_vid_mplane_default;
+	csi2_be_soc->av.prepare_fw_stream =
+		ipu_isys_prepare_fw_cfg_default;
+	csi2_be_soc->av.aq.buf_prepare = ipu_isys_buf_prepare;
+	csi2_be_soc->av.aq.fill_frame_buff_set_pin =
+		ipu_isys_buffer_to_fw_frame_buff_pin;
+	csi2_be_soc->av.aq.link_fmt_validate = ipu_isys_link_fmt_validate;
+	csi2_be_soc->av.aq.vbq.buf_struct_size =
+		sizeof(struct ipu_isys_video_buffer);
+
+	/* create v4l2 ctrl for be-soc video node */
+	rval = v4l2_ctrl_handler_init(&csi2_be_soc->av.ctrl_handler, 0);
+	if (rval) {
+		dev_err(&isys->adev->dev,
+			"failed to init v4l2 ctrl handler for be_soc\n");
+		goto fail;
 	}
 
-	for (i = 0; i < NR_OF_CSI2_BE_SOC_SOURCE_PADS; i++) {
-		csi2_be_soc->asd.stream[CSI2_BE_SOC_PAD_SINK(i)].stream_id[0]
-		    = 0;
-		csi2_be_soc->asd.stream[CSI2_BE_SOC_PAD_SOURCE(i)].stream_id[0]
-		    = 0;
-	}
-	for (i = 0; i < NR_OF_CSI2_BE_SOC_STREAMS; i++) {
-		csi2_be_soc->asd.route[i].flags = V4L2_SUBDEV_ROUTE_FL_ACTIVE;
-		bitmap_set(csi2_be_soc->asd.stream[CSI2_BE_SOC_PAD_SINK(i)].
-			   streams_stat, 0, 1);
-		bitmap_set(csi2_be_soc->asd.stream[CSI2_BE_SOC_PAD_SOURCE(i)].
-			   streams_stat, 0, 1);
+	csi2_be_soc->av.compression_ctrl =
+		v4l2_ctrl_new_custom(&csi2_be_soc->av.ctrl_handler,
+				     &compression_ctrl_cfg, NULL);
+	if (!csi2_be_soc->av.compression_ctrl) {
+		dev_err(&isys->adev->dev,
+			"failed to create BE-SOC cmprs ctrl\n");
+		goto fail;
 	}
-	csi2_be_soc->asd.route[0].flags |= V4L2_SUBDEV_ROUTE_FL_IMMUTABLE;
-	mutex_unlock(&csi2_be_soc->asd.mutex);
-	for (i = 0; i < NR_OF_CSI2_BE_SOC_SOURCE_PADS; i++) {
-		snprintf(csi2_be_soc->av[i].vdev.name,
-			 sizeof(csi2_be_soc->av[i].vdev.name),
-			 IPU_ISYS_ENTITY_PREFIX " BE SOC capture %d", i);
-		/*
-		 * Pin type could be overwritten for YUV422 to I420 case, at
-		 * set_format phase
-		 */
-		csi2_be_soc->av[i].aq.css_pin_type =
-			IPU_FW_ISYS_PIN_TYPE_RAW_SOC;
-		csi2_be_soc->av[i].isys = isys;
-		csi2_be_soc->av[i].pfmts = ipu_isys_pfmts_be_soc;
-
-		csi2_be_soc->av[i].try_fmt_vid_mplane =
-		    ipu_isys_video_try_fmt_vid_mplane_default;
-		csi2_be_soc->av[i].prepare_firmware_stream_cfg =
-		    ipu_isys_prepare_firmware_stream_cfg_default;
-		csi2_be_soc->av[i].aq.buf_prepare = ipu_isys_buf_prepare;
-		csi2_be_soc->av[i].aq.fill_frame_buff_set_pin =
-		    ipu_isys_buffer_list_to_ipu_fw_isys_frame_buff_set_pin;
-		csi2_be_soc->av[i].aq.link_fmt_validate =
-		    ipu_isys_link_fmt_validate;
-		csi2_be_soc->av[i].aq.vbq.buf_struct_size =
-		    sizeof(struct ipu_isys_video_buffer);
-
-		rval = ipu_isys_video_init(&csi2_be_soc->av[i],
-					   &csi2_be_soc->asd.sd.entity,
-					   CSI2_BE_SOC_PAD_SOURCE(i),
-					   MEDIA_PAD_FL_SINK,
-					   MEDIA_LNK_FL_DYNAMIC);
-		if (rval) {
-			dev_info(&isys->adev->dev, "can't init video node\n");
-			goto fail;
-		}
+	csi2_be_soc->av.compression = 0;
+	csi2_be_soc->av.vdev.ctrl_handler =
+		&csi2_be_soc->av.ctrl_handler;
+
+	rval = ipu_isys_video_init(&csi2_be_soc->av,
+				   &csi2_be_soc->asd.sd.entity,
+				   CSI2_BE_SOC_PAD_SOURCE,
+				   MEDIA_PAD_FL_SINK,
+				   MEDIA_LNK_FL_DYNAMIC);
+	if (rval) {
+		dev_info(&isys->adev->dev, "can't init video node\n");
+		goto fail;
 	}
 
 	return 0;
diff --git a/drivers/media/pci/intel/ipu-isys-csi2-be.c b/drivers/media/pci/intel/ipu-isys-csi2-be.c
index bbf1b3ff5f9f..b2b69aea4755 100644
--- a/drivers/media/pci/intel/ipu-isys-csi2-be.c
+++ b/drivers/media/pci/intel/ipu-isys-csi2-be.c
@@ -96,7 +96,7 @@ static int ipu_isys_csi2_be_set_sel(struct v4l2_subdev *sd,
 	    pad->flags & MEDIA_PAD_FL_SOURCE &&
 	    asd->valid_tgts[CSI2_BE_PAD_SOURCE].crop) {
 		struct v4l2_mbus_framefmt *ffmt =
-			__ipu_isys_get_ffmt(sd, state, sel->pad, 0, sel->which);
+			__ipu_isys_get_ffmt(sd, state, sel->pad, sel->which);
 		struct v4l2_rect *r = __ipu_isys_get_selection
 		    (sd, state, sel->target, CSI2_BE_PAD_SINK, sel->which);
 
@@ -156,8 +156,7 @@ static void csi2_be_set_ffmt(struct v4l2_subdev *sd,
 {
 	struct ipu_isys_csi2 *csi2 = to_ipu_isys_csi2(sd);
 	struct v4l2_mbus_framefmt *ffmt =
-		__ipu_isys_get_ffmt(sd, state, fmt->pad, fmt->stream,
-				    fmt->which);
+		__ipu_isys_get_ffmt(sd, state, fmt->pad, fmt->which);
 
 	switch (fmt->pad) {
 	case CSI2_BE_PAD_SINK:
@@ -172,7 +171,7 @@ static void csi2_be_set_ffmt(struct v4l2_subdev *sd,
 	case CSI2_BE_PAD_SOURCE: {
 		struct v4l2_mbus_framefmt *sink_ffmt =
 			__ipu_isys_get_ffmt(sd, state, CSI2_BE_PAD_SINK,
-					    fmt->stream, fmt->which);
+					    fmt->which);
 		struct v4l2_rect *r =
 			__ipu_isys_get_selection(sd, state, V4L2_SEL_TGT_CROP,
 						 CSI2_BE_PAD_SOURCE,
@@ -238,15 +237,14 @@ int ipu_isys_csi2_be_init(struct ipu_isys_csi2_be *csi2_be,
 
 	rval = ipu_isys_subdev_init(&csi2_be->asd, &csi2_be_sd_ops, 0,
 				    NR_OF_CSI2_BE_PADS,
-				    NR_OF_CSI2_BE_STREAMS,
 				    NR_OF_CSI2_BE_SOURCE_PADS,
-				    NR_OF_CSI2_BE_SINK_PADS, 0);
+				    NR_OF_CSI2_BE_SINK_PADS, 0,
+				    CSI2_BE_PAD_SOURCE,
+				    CSI2_BE_PAD_SINK);
 	if (rval)
 		goto fail;
 
-	csi2_be->asd.pad[CSI2_BE_PAD_SINK].flags = MEDIA_PAD_FL_SINK
-	    | MEDIA_PAD_FL_MUST_CONNECT;
-	csi2_be->asd.pad[CSI2_BE_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	csi2_be->asd.pad[CSI2_BE_PAD_SINK].flags |= MEDIA_PAD_FL_MUST_CONNECT;
 	csi2_be->asd.valid_tgts[CSI2_BE_PAD_SOURCE].crop = true;
 	csi2_be->asd.set_ffmt = csi2_be_set_ffmt;
 
@@ -275,15 +273,34 @@ int ipu_isys_csi2_be_init(struct ipu_isys_csi2_be *csi2_be,
 	csi2_be->av.pfmts = ipu_isys_pfmts;
 	csi2_be->av.try_fmt_vid_mplane =
 	    ipu_isys_video_try_fmt_vid_mplane_default;
-	csi2_be->av.prepare_firmware_stream_cfg =
-	    ipu_isys_prepare_firmware_stream_cfg_default;
+	csi2_be->av.prepare_fw_stream =
+	    ipu_isys_prepare_fw_cfg_default;
 	csi2_be->av.aq.buf_prepare = ipu_isys_buf_prepare;
 	csi2_be->av.aq.fill_frame_buff_set_pin =
-	    ipu_isys_buffer_list_to_ipu_fw_isys_frame_buff_set_pin;
+	    ipu_isys_buffer_to_fw_frame_buff_pin;
 	csi2_be->av.aq.link_fmt_validate = ipu_isys_link_fmt_validate;
 	csi2_be->av.aq.vbq.buf_struct_size =
 	    sizeof(struct ipu_isys_video_buffer);
 
+	/* create v4l2 ctrl for csi-be video node */
+	rval = v4l2_ctrl_handler_init(&csi2_be->av.ctrl_handler, 0);
+	if (rval) {
+		dev_err(&isys->adev->dev,
+			"failed to init v4l2 ctrl handler for csi2_be\n");
+		goto fail;
+	}
+
+	csi2_be->av.compression_ctrl =
+		v4l2_ctrl_new_custom(&csi2_be->av.ctrl_handler,
+				     &compression_ctrl_cfg, NULL);
+	if (!csi2_be->av.compression_ctrl) {
+		dev_err(&isys->adev->dev,
+			"failed to create CSI-BE cmprs ctrl\n");
+		goto fail;
+	}
+	csi2_be->av.compression = 0;
+	csi2_be->av.vdev.ctrl_handler = &csi2_be->av.ctrl_handler;
+
 	rval = ipu_isys_video_init(&csi2_be->av, &csi2_be->asd.sd.entity,
 				   CSI2_BE_PAD_SOURCE, MEDIA_PAD_FL_SINK, 0);
 	if (rval) {
diff --git a/drivers/media/pci/intel/ipu-isys-csi2-be.h b/drivers/media/pci/intel/ipu-isys-csi2-be.h
index 28c2895d9a33..414d1dd7c28c 100644
--- a/drivers/media/pci/intel/ipu-isys-csi2-be.h
+++ b/drivers/media/pci/intel/ipu-isys-csi2-be.h
@@ -27,15 +27,8 @@ struct ipu_isys;
 #define NR_OF_CSI2_BE_STREAMS	1
 #define NR_OF_CSI2_BE_SOC_SOURCE_PADS	NR_OF_CSI2_BE_SOC_STREAMS
 #define NR_OF_CSI2_BE_SOC_SINK_PADS	NR_OF_CSI2_BE_SOC_STREAMS
-#define CSI2_BE_SOC_PAD_SINK(n)		\
-	({ typeof(n) __n = (n);	\
-	   (__n) >= NR_OF_CSI2_BE_SOC_SINK_PADS ?	\
-	   (NR_OF_CSI2_BE_SOC_SINK_PADS) : (__n); })
-#define CSI2_BE_SOC_PAD_SOURCE(n)	\
-	({ typeof(n) __n = (n);  \
-	   (__n) >= NR_OF_CSI2_BE_SOC_SOURCE_PADS ? \
-		(NR_OF_CSI2_BE_SOC_PADS - 1) : \
-		((__n) + NR_OF_CSI2_BE_SOC_SINK_PADS); })
+#define CSI2_BE_SOC_PAD_SINK 0
+#define CSI2_BE_SOC_PAD_SOURCE 1
 #define NR_OF_CSI2_BE_SOC_PADS \
 	(NR_OF_CSI2_BE_SOC_SOURCE_PADS + NR_OF_CSI2_BE_SOC_SINK_PADS)
 
@@ -55,7 +48,7 @@ struct ipu_isys_csi2_be {
 struct ipu_isys_csi2_be_soc {
 	struct ipu_isys_csi2_be_pdata *pdata;
 	struct ipu_isys_subdev asd;
-	struct ipu_isys_video av[NR_OF_CSI2_BE_SOC_SOURCE_PADS];
+	struct ipu_isys_video av;
 };
 
 #define to_ipu_isys_csi2_be(sd)	\
@@ -68,8 +61,8 @@ struct ipu_isys_csi2_be_soc {
 
 int ipu_isys_csi2_be_init(struct ipu_isys_csi2_be *csi2_be,
 			  struct ipu_isys *isys);
-int ipu_isys_csi2_be_soc_init(
-	struct ipu_isys_csi2_be_soc *csi2_be_soc, struct ipu_isys *isys);
+int ipu_isys_csi2_be_soc_init(struct ipu_isys_csi2_be_soc *csi2_be_soc,
+			      struct ipu_isys *isys, int index);
 void ipu_isys_csi2_be_cleanup(struct ipu_isys_csi2_be *csi2_be);
 void ipu_isys_csi2_be_soc_cleanup(struct ipu_isys_csi2_be_soc *csi2_be);
 
diff --git a/drivers/media/pci/intel/ipu-isys-csi2.c b/drivers/media/pci/intel/ipu-isys-csi2.c
index 67bcc112aa3c..f2fd6423c662 100644
--- a/drivers/media/pci/intel/ipu-isys-csi2.c
+++ b/drivers/media/pci/intel/ipu-isys-csi2.c
@@ -90,44 +90,35 @@ static struct v4l2_subdev_internal_ops csi2_sd_internal_ops = {
 	.close = ipu_isys_subdev_close,
 };
 
-int ipu_isys_csi2_get_link_freq(struct ipu_isys_csi2 *csi2, __s64 *link_freq)
+int ipu_isys_csi2_get_link_freq(struct ipu_isys_csi2 *csi2, s64 *link_freq)
 {
-	struct ipu_isys_pipeline *pipe = container_of(media_entity_pipeline(&csi2->asd.sd.entity),
+	struct media_pipeline *mp = media_entity_pipeline(&csi2->asd.sd.entity);
+	struct ipu_isys_pipeline *pipe = container_of(mp,
 						      struct ipu_isys_pipeline,
 						      pipe);
 	struct v4l2_subdev *ext_sd =
-	    media_entity_to_v4l2_subdev(pipe->external->entity);
-	struct v4l2_ext_control c = {.id = V4L2_CID_LINK_FREQ, };
-	struct v4l2_ext_controls cs = {.count = 1,
-		.controls = &c,
-	};
-	struct v4l2_querymenu qm = {.id = c.id, };
-	int rval;
+		media_entity_to_v4l2_subdev(pipe->external->entity);
+	struct device *dev = &csi2->isys->adev->dev;
+	unsigned int bpp, lanes;
+	s64 ret;
 
 	if (!ext_sd) {
 		WARN_ON(1);
 		return -ENODEV;
 	}
-	rval = v4l2_g_ext_ctrls(ext_sd->ctrl_handler, &csi2->av_meta.vdev, &csi2->isys->media_dev, &cs);
-	if (rval) {
-		dev_info(&csi2->isys->adev->dev, "can't get link frequency\n");
-		return rval;
-	}
 
-	qm.index = c.value;
+	bpp = ipu_isys_mbus_code_to_bpp(csi2->asd.ffmt->code);
+	lanes = csi2->nlanes;
 
-	rval = v4l2_querymenu(ext_sd->ctrl_handler, &qm);
-	if (rval) {
-		dev_info(&csi2->isys->adev->dev, "can't get menu item\n");
-		return rval;
+	ret = v4l2_get_link_freq(ext_sd->ctrl_handler, bpp, lanes * 2);
+	if (ret < 0) {
+		dev_err(dev, "can't get link frequency (%lld)\n", ret);
+		return ret;
 	}
 
-	dev_dbg(&csi2->isys->adev->dev, "%s: link frequency %lld\n", __func__,
-		qm.value);
+	dev_dbg(dev, "link freq of %s is %lld\n", ext_sd->name, ret);
+	*link_freq = ret;
 
-	if (!qm.value)
-		return -EINVAL;
-	*link_freq = qm.value;
 	return 0;
 }
 
@@ -154,45 +145,6 @@ static int ipu_get_frame_desc_entry_by_dt(struct v4l2_subdev *sd,
 	return -EINVAL;
 }
 
-static void csi2_meta_prepare_firmware_stream_cfg_default(
-			struct ipu_isys_video *av,
-			struct ipu_fw_isys_stream_cfg_data_abi *cfg)
-{
-	struct ipu_isys_pipeline *ip =
-	    to_ipu_isys_pipeline(media_entity_pipeline(&av->vdev.entity));
-	struct ipu_isys_queue *aq = &av->aq;
-	struct ipu_fw_isys_output_pin_info_abi *pin_info;
-	struct v4l2_mbus_frame_desc_entry entry;
-	int pin = cfg->nof_output_pins++;
-	int inpin = cfg->nof_input_pins++;
-	int rval;
-
-	aq->fw_output = pin;
-	ip->output_pins[pin].pin_ready = ipu_isys_queue_buf_ready;
-	ip->output_pins[pin].aq = aq;
-
-	pin_info = &cfg->output_pins[pin];
-	pin_info->input_pin_id = inpin;
-	pin_info->output_res.width = av->mpix.width;
-	pin_info->output_res.height = av->mpix.height;
-	pin_info->stride = av->mpix.plane_fmt[0].bytesperline;
-	pin_info->pt = aq->css_pin_type;
-	pin_info->ft = av->pfmt->css_pixelformat;
-	pin_info->send_irq = 1;
-
-	rval =
-	    ipu_get_frame_desc_entry_by_dt(media_entity_to_v4l2_subdev
-					   (ip->external->entity), &entry,
-					   IPU_ISYS_MIPI_CSI2_TYPE_EMBEDDED8);
-	if (!rval) {
-		cfg->input_pins[inpin].dt = IPU_ISYS_MIPI_CSI2_TYPE_EMBEDDED8;
-		cfg->input_pins[inpin].input_res.width =
-		    entry.two_dim.width * entry.bpp / BITS_PER_BYTE;
-		cfg->input_pins[inpin].input_res.height =
-		    entry.two_dim.height;
-	}
-}
-
 static int subscribe_event(struct v4l2_subdev *sd, struct v4l2_fh *fh,
 			   struct v4l2_event_subscription *sub)
 {
@@ -216,11 +168,6 @@ static const struct v4l2_subdev_core_ops csi2_sd_core_ops = {
 	.unsubscribe_event = v4l2_event_subdev_unsubscribe,
 };
 
-static struct ipu_isys_pixelformat csi2_meta_pfmts[] = {
-	{V4L2_FMT_IPU_ISYS_META, 8, 8, 0, MEDIA_BUS_FMT_FIXED, 0},
-	{},
-};
-
 /*
  * The input system CSI2+ receiver has several
  * parameters affecting the receiver timings. These depend
@@ -297,17 +244,18 @@ ipu_isys_csi2_calc_timing(struct ipu_isys_csi2 *csi2,
 static int set_stream(struct v4l2_subdev *sd, int enable)
 {
 	struct ipu_isys_csi2 *csi2 = to_ipu_isys_csi2(sd);
-	struct ipu_isys_pipeline *ip = container_of(media_entity_pipeline(&sd->entity),
+	struct media_pipeline *mp = media_entity_pipeline(&sd->entity);
+	struct ipu_isys_pipeline *ip = container_of(mp,
 						    struct ipu_isys_pipeline,
 						    pipe);
 	struct ipu_isys_csi2_config *cfg;
 	struct v4l2_subdev *ext_sd;
-	struct v4l2_control c = {.id = V4L2_CID_MIPI_LANES, };
-	struct ipu_isys_csi2_timing timing;
+	struct ipu_isys_csi2_timing timing = {0};
 	unsigned int nlanes;
 	int rval;
 
-	dev_dbg(&csi2->isys->adev->dev, "csi2 s_stream %d\n", enable);
+	dev_dbg(&csi2->isys->adev->dev, "csi2 s_stream %d for entity %s\n",
+		enable, sd->entity.name);
 
 	if (!ip->external->entity) {
 		WARN_ON(1);
@@ -317,58 +265,23 @@ static int set_stream(struct v4l2_subdev *sd, int enable)
 	cfg = v4l2_get_subdev_hostdata(ext_sd);
 
 	if (!enable) {
-		csi2->stream_count--;
-		if (csi2->stream_count)
-			return 0;
-
 		ipu_isys_csi2_set_stream(sd, timing, 0, enable);
 		return 0;
 	}
 
 	ip->has_sof = true;
 
-	if (csi2->stream_count) {
-		csi2->stream_count++;
-		return 0;
-	}
+	nlanes = cfg->nlanes;
 
-	rval = v4l2_g_ctrl(ext_sd->ctrl_handler, &c);
-	if (!rval && c.value > 0 && cfg->nlanes > c.value) {
-		nlanes = c.value;
-		dev_dbg(&csi2->isys->adev->dev, "lane nr %d.\n", nlanes);
-	} else {
-		nlanes = cfg->nlanes;
-	}
+	dev_dbg(&csi2->isys->adev->dev, "lane nr %d.\n", nlanes);
 
 	rval = ipu_isys_csi2_calc_timing(csi2, &timing, CSI2_ACCINV);
 	if (rval)
 		return rval;
 
-	ipu_isys_csi2_set_stream(sd, timing, nlanes, enable);
-	csi2->stream_count++;
+	rval = ipu_isys_csi2_set_stream(sd, timing, nlanes, enable);
 
-	return 0;
-}
-
-static void csi2_capture_done(struct ipu_isys_pipeline *ip,
-			      struct ipu_fw_isys_resp_info_abi *info)
-{
-	if (ip->interlaced && ip->isys->short_packet_source ==
-	    IPU_ISYS_SHORT_PACKET_FROM_RECEIVER) {
-		struct ipu_isys_buffer *ib;
-		unsigned long flags;
-
-		spin_lock_irqsave(&ip->short_packet_queue_lock, flags);
-		if (!list_empty(&ip->short_packet_active)) {
-			ib = list_last_entry(&ip->short_packet_active,
-					     struct ipu_isys_buffer, head);
-			list_move(&ib->head, &ip->short_packet_incoming);
-		}
-		spin_unlock_irqrestore(&ip->short_packet_queue_lock, flags);
-	}
-	if (ip->csi2) {
-		ipu_isys_csi2_error(ip->csi2);
-	}
+	return rval;
 }
 
 static bool csi2_has_route(struct media_entity *entity, unsigned int pad0,
@@ -469,7 +382,6 @@ static void csi2_set_ffmt(struct v4l2_subdev *sd,
 {
 	struct v4l2_mbus_framefmt *ffmt =
 		__ipu_isys_get_ffmt(sd, state, fmt->pad,
-				    fmt->stream,
 				    fmt->which);
 
 	if (fmt->format.field != V4L2_FIELD_ALTERNATE)
@@ -489,7 +401,6 @@ static void csi2_set_ffmt(struct v4l2_subdev *sd,
 	if (fmt->pad == CSI2_PAD_META) {
 		struct v4l2_mbus_framefmt *ffmt =
 			__ipu_isys_get_ffmt(sd, state, fmt->pad,
-					    fmt->stream,
 					    fmt->which);
 		struct media_pad *pad = media_pad_remote_pad_first(
 			&sd->entity.pads[CSI2_PAD_SINK]);
@@ -530,37 +441,13 @@ static void csi2_set_ffmt(struct v4l2_subdev *sd,
 	WARN_ON(1);
 }
 
-static const struct ipu_isys_pixelformat *
-csi2_try_fmt(struct ipu_isys_video *av,
-	     struct v4l2_pix_format_mplane *mpix)
-{
-	struct media_link *link = list_first_entry(&av->vdev.entity.links,
-						   struct media_link, list);
-	struct v4l2_subdev *sd =
-	    media_entity_to_v4l2_subdev(link->source->entity);
-	struct ipu_isys_csi2 *csi2;
-
-	if (!sd)
-		return NULL;
-
-	csi2 = to_ipu_isys_csi2(sd);
-
-	return ipu_isys_video_try_fmt_vid_mplane(av, mpix,
-				v4l2_ctrl_g_ctrl(csi2->store_csi2_header));
-}
-
 void ipu_isys_csi2_cleanup(struct ipu_isys_csi2 *csi2)
 {
-	int i;
-
 	if (!csi2->isys)
 		return;
 
 	v4l2_device_unregister_subdev(&csi2->asd.sd);
 	ipu_isys_subdev_cleanup(&csi2->asd);
-	for (i = 0; i < NR_OF_CSI2_SOURCE_PADS; i++)
-		ipu_isys_video_cleanup(&csi2->av[i]);
-	ipu_isys_video_cleanup(&csi2->av_meta);
 	csi2->isys = NULL;
 }
 
@@ -594,12 +481,10 @@ int ipu_isys_csi2_init(struct ipu_isys_csi2 *csi2,
 			   .height = 3072,
 			  },
 	};
-	struct v4l2_subdev_format fmt_meta = {
-		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
-		.pad = CSI2_PAD_META,
-	};
 	int i, rval, src;
 
+	dev_dbg(&isys->adev->dev, "csi-%d base = 0x%lx\n", index,
+		(unsigned long)base);
 	csi2->isys = isys;
 	csi2->base = base;
 	csi2->index = index;
@@ -608,35 +493,23 @@ int ipu_isys_csi2_init(struct ipu_isys_csi2 *csi2,
 	csi2->asd.ctrl_init = csi_ctrl_init;
 	csi2->asd.isys = isys;
 	init_completion(&csi2->eof_completion);
-	csi2->remote_streams = 1;
-	csi2->stream_count = 0;
-
 	rval = ipu_isys_subdev_init(&csi2->asd, &csi2_sd_ops, 0,
 				    NR_OF_CSI2_PADS,
-				    NR_OF_CSI2_STREAMS,
 				    NR_OF_CSI2_SOURCE_PADS,
-				    NR_OF_CSI2_SINK_PADS,
-				    V4L2_SUBDEV_FL_HAS_SUBSTREAMS);
+				    NR_OF_CSI2_SINK_PADS, 0,
+				    CSI2_PAD_SOURCE,
+				    CSI2_PAD_SINK);
 	if (rval)
 		goto fail;
 
-	csi2->asd.pad[CSI2_PAD_SINK].flags = MEDIA_PAD_FL_SINK
-	    | MEDIA_PAD_FL_MUST_CONNECT | MEDIA_PAD_FL_MULTIPLEX;
-	for (i = CSI2_PAD_SOURCE(0);
-	     i < (NR_OF_CSI2_SOURCE_PADS + CSI2_PAD_SOURCE(0)); i++)
-		csi2->asd.pad[i].flags = MEDIA_PAD_FL_SOURCE;
+	csi2->asd.pad[CSI2_PAD_SINK].flags |= MEDIA_PAD_FL_MUST_CONNECT;
 
-	csi2->asd.pad[CSI2_PAD_META].flags = MEDIA_PAD_FL_SOURCE;
 	src = index;
-#ifdef CONFIG_VIDEO_INTEL_IPU4P
-	src = index ? (index + 5) : (index + 3);
-#endif
 	csi2->asd.source = IPU_FW_ISYS_STREAM_SRC_CSI2_PORT0 + src;
 	csi2_supported_codes[CSI2_PAD_SINK] = csi2_supported_codes_pad_sink;
 
 	for (i = 0; i < NR_OF_CSI2_SOURCE_PADS; i++)
 		csi2_supported_codes[i + 1] = csi2_supported_codes_pad_source;
-	csi2_supported_codes[CSI2_PAD_META] = csi2_supported_codes_pad_meta;
 	csi2->asd.supported_codes = csi2_supported_codes;
 	csi2->asd.set_ffmt = csi2_set_ffmt;
 
@@ -646,94 +519,16 @@ int ipu_isys_csi2_init(struct ipu_isys_csi2 *csi2,
 		 IPU_ISYS_ENTITY_PREFIX " CSI-2 %u", index);
 	v4l2_set_subdevdata(&csi2->asd.sd, &csi2->asd);
 
-	mutex_lock(&csi2->asd.mutex);
 	rval = v4l2_device_register_subdev(&isys->v4l2_dev, &csi2->asd.sd);
 	if (rval) {
-		mutex_unlock(&csi2->asd.mutex);
 		dev_info(&isys->adev->dev, "can't register v4l2 subdev\n");
 		goto fail;
 	}
 
+	mutex_lock(&csi2->asd.mutex);
 	__ipu_isys_subdev_set_ffmt(&csi2->asd.sd, NULL, &fmt);
-	__ipu_isys_subdev_set_ffmt(&csi2->asd.sd, NULL, &fmt_meta);
-
-	/* create default route information */
-	for (i = 0; i < NR_OF_CSI2_STREAMS; i++) {
-		csi2->asd.route[i].sink = CSI2_PAD_SINK;
-		csi2->asd.route[i].source = CSI2_PAD_SOURCE(i);
-		csi2->asd.route[i].flags = 0;
-	}
-
-	for (i = 0; i < NR_OF_CSI2_SOURCE_PADS; i++) {
-		csi2->asd.stream[CSI2_PAD_SINK].stream_id[i] = i;
-		csi2->asd.stream[CSI2_PAD_SOURCE(i)].stream_id[CSI2_PAD_SINK]
-		    = i;
-	}
-	csi2->asd.route[0].flags = V4L2_SUBDEV_ROUTE_FL_ACTIVE |
-	    V4L2_SUBDEV_ROUTE_FL_IMMUTABLE;
-	bitmap_set(csi2->asd.stream[CSI2_PAD_SINK].streams_stat, 0, 1);
-	bitmap_set(csi2->asd.stream[CSI2_PAD_SOURCE(0)].streams_stat, 0, 1);
-
 	mutex_unlock(&csi2->asd.mutex);
 
-	for (i = 0; i < NR_OF_CSI2_SOURCE_PADS; i++) {
-		snprintf(csi2->av[i].vdev.name, sizeof(csi2->av[i].vdev.name),
-			 IPU_ISYS_ENTITY_PREFIX " CSI-2 %u capture %d",
-			 index, i);
-		csi2->av[i].isys = isys;
-		csi2->av[i].aq.css_pin_type = IPU_FW_ISYS_PIN_TYPE_MIPI;
-		csi2->av[i].pfmts = ipu_isys_pfmts_packed;
-		csi2->av[i].try_fmt_vid_mplane = csi2_try_fmt;
-		csi2->av[i].prepare_firmware_stream_cfg =
-		    ipu_isys_prepare_firmware_stream_cfg_default;
-		csi2->av[i].packed = true;
-		csi2->av[i].line_header_length =
-		    IPU_ISYS_CSI2_LONG_PACKET_HEADER_SIZE;
-		csi2->av[i].line_footer_length =
-		    IPU_ISYS_CSI2_LONG_PACKET_FOOTER_SIZE;
-		csi2->av[i].aq.buf_prepare = ipu_isys_buf_prepare;
-		csi2->av[i].aq.fill_frame_buff_set_pin =
-		    ipu_isys_buffer_list_to_ipu_fw_isys_frame_buff_set_pin;
-		csi2->av[i].aq.link_fmt_validate = ipu_isys_link_fmt_validate;
-		csi2->av[i].aq.vbq.buf_struct_size =
-		    sizeof(struct ipu_isys_video_buffer);
-
-		rval = ipu_isys_video_init(&csi2->av[i],
-					   &csi2->asd.sd.entity,
-					   CSI2_PAD_SOURCE(i),
-					   MEDIA_PAD_FL_SINK, 0);
-		if (rval) {
-			dev_info(&isys->adev->dev, "can't init video node\n");
-			goto fail;
-		}
-	}
-
-	snprintf(csi2->av_meta.vdev.name, sizeof(csi2->av_meta.vdev.name),
-		 IPU_ISYS_ENTITY_PREFIX " CSI-2 %u meta", index);
-	csi2->av_meta.isys = isys;
-	csi2->av_meta.aq.css_pin_type = IPU_FW_ISYS_PIN_TYPE_MIPI;
-	csi2->av_meta.pfmts = csi2_meta_pfmts;
-	csi2->av_meta.try_fmt_vid_mplane = csi2_try_fmt;
-	csi2->av_meta.prepare_firmware_stream_cfg =
-	    csi2_meta_prepare_firmware_stream_cfg_default;
-	csi2->av_meta.packed = true;
-	csi2->av_meta.line_header_length =
-	    IPU_ISYS_CSI2_LONG_PACKET_HEADER_SIZE;
-	csi2->av_meta.line_footer_length =
-	    IPU_ISYS_CSI2_LONG_PACKET_FOOTER_SIZE;
-	csi2->av_meta.aq.buf_prepare = ipu_isys_buf_prepare;
-	csi2->av_meta.aq.fill_frame_buff_set_pin =
-	    ipu_isys_buffer_list_to_ipu_fw_isys_frame_buff_set_pin;
-	csi2->av_meta.aq.link_fmt_validate = ipu_isys_link_fmt_validate;
-	csi2->av_meta.aq.vbq.buf_struct_size =
-	    sizeof(struct ipu_isys_video_buffer);
-
-	rval = ipu_isys_video_init(&csi2->av_meta, &csi2->asd.sd.entity,
-				   CSI2_PAD_META, MEDIA_PAD_FL_SINK, 0);
-	if (rval) {
-		dev_info(&isys->adev->dev, "can't init metadata node\n");
-		goto fail;
-	}
 	return 0;
 
 fail:
@@ -742,7 +537,7 @@ int ipu_isys_csi2_init(struct ipu_isys_csi2 *csi2,
 	return rval;
 }
 
-void ipu_isys_csi2_sof_event(struct ipu_isys_csi2 *csi2, unsigned int vc)
+void ipu_isys_csi2_sof_event(struct ipu_isys_csi2 *csi2)
 {
 	struct ipu_isys_pipeline *ip = NULL;
 	struct v4l2_event ev = {
@@ -753,11 +548,10 @@ void ipu_isys_csi2_sof_event(struct ipu_isys_csi2 *csi2, unsigned int vc)
 	unsigned int i;
 
 	spin_lock_irqsave(&csi2->isys->lock, flags);
-	csi2->in_frame[vc] = true;
+	csi2->in_frame = true;
 
 	for (i = 0; i < IPU_ISYS_MAX_STREAMS; i++) {
 		if (csi2->isys->pipes[i] &&
-		    csi2->isys->pipes[i]->vc == vc &&
 		    csi2->isys->pipes[i]->csi2 == csi2) {
 			ip = csi2->isys->pipes[i];
 			break;
@@ -771,17 +565,15 @@ void ipu_isys_csi2_sof_event(struct ipu_isys_csi2 *csi2, unsigned int vc)
 	}
 
 	ev.u.frame_sync.frame_sequence = atomic_inc_return(&ip->sequence) - 1;
-	ev.id = ip->stream_id;
 	spin_unlock_irqrestore(&csi2->isys->lock, flags);
 
-	trace_ipu_sof_seqid(ev.u.frame_sync.frame_sequence, csi2->index, vc);
 	v4l2_event_queue(vdev, &ev);
 	dev_dbg(&csi2->isys->adev->dev,
-		"sof_event::csi2-%i CPU-timestamp:%lld, sequence:%i, vc:%d, stream_id:%d\n",
-		csi2->index, ktime_get_ns(), ev.u.frame_sync.frame_sequence, vc, ip->stream_id);
+		"sof_event::csi2-%i sequence: %i\n",
+		csi2->index, ev.u.frame_sync.frame_sequence);
 }
 
-void ipu_isys_csi2_eof_event(struct ipu_isys_csi2 *csi2, unsigned int vc)
+void ipu_isys_csi2_eof_event(struct ipu_isys_csi2 *csi2)
 {
 	struct ipu_isys_pipeline *ip = NULL;
 	unsigned long flags;
@@ -789,14 +581,12 @@ void ipu_isys_csi2_eof_event(struct ipu_isys_csi2 *csi2, unsigned int vc)
 	u32 frame_sequence;
 
 	spin_lock_irqsave(&csi2->isys->lock, flags);
-	csi2->in_frame[vc] = false;
-	if (csi2->wait_for_sync[vc])
+	csi2->in_frame = false;
+	if (csi2->wait_for_sync)
 		complete(&csi2->eof_completion);
-	spin_unlock_irqrestore(&csi2->isys->lock, flags);
 
 	for (i = 0; i < IPU_ISYS_MAX_STREAMS; i++) {
 		if (csi2->isys->pipes[i] &&
-		    csi2->isys->pipes[i]->vc == vc &&
 		    csi2->isys->pipes[i]->csi2 == csi2) {
 			ip = csi2->isys->pipes[i];
 			break;
@@ -805,40 +595,39 @@ void ipu_isys_csi2_eof_event(struct ipu_isys_csi2 *csi2, unsigned int vc)
 
 	if (ip) {
 		frame_sequence = atomic_read(&ip->sequence);
-
-	trace_ipu_eof_seqid(frame_sequence, csi2->index, vc);
+		spin_unlock_irqrestore(&csi2->isys->lock, flags);
 
 		dev_dbg(&csi2->isys->adev->dev,
-			"eof_event::csi2-%i sequence: %i, vc: %d, stream_id: %d\n",
-			csi2->index, frame_sequence, vc, ip->stream_id);
+			"eof_event::csi2-%i sequence: %i\n",
+			csi2->index, frame_sequence);
+		return;
 	}
+
+	spin_unlock_irqrestore(&csi2->isys->lock, flags);
 }
 
 /* Call this function only _after_ the sensor has been stopped */
 void ipu_isys_csi2_wait_last_eof(struct ipu_isys_csi2 *csi2)
 {
 	unsigned long flags, tout;
-	unsigned int i;
-
-	for (i = 0; i < NR_OF_CSI2_VC; i++) {
-		spin_lock_irqsave(&csi2->isys->lock, flags);
 
-		if (!csi2->in_frame[i]) {
-			spin_unlock_irqrestore(&csi2->isys->lock, flags);
-			continue;
-		}
+	spin_lock_irqsave(&csi2->isys->lock, flags);
 
-		reinit_completion(&csi2->eof_completion);
-		csi2->wait_for_sync[i] = true;
+	if (!csi2->in_frame) {
 		spin_unlock_irqrestore(&csi2->isys->lock, flags);
-		tout = wait_for_completion_timeout(&csi2->eof_completion,
-						   IPU_EOF_TIMEOUT_JIFFIES);
-		if (!tout)
-			dev_err(&csi2->isys->adev->dev,
-				"csi2-%d: timeout at sync to eof of vc %d\n",
-				csi2->index, i);
-		csi2->wait_for_sync[i] = false;
+		return;
 	}
+
+	reinit_completion(&csi2->eof_completion);
+	csi2->wait_for_sync = true;
+	spin_unlock_irqrestore(&csi2->isys->lock, flags);
+	tout = wait_for_completion_timeout(&csi2->eof_completion,
+					   IPU_EOF_TIMEOUT_JIFFIES);
+	if (!tout)
+		dev_err(&csi2->isys->adev->dev,
+			"csi2-%d: timeout at sync to eof\n",
+			csi2->index);
+	csi2->wait_for_sync = false;
 }
 
 struct ipu_isys_buffer *ipu_isys_csi2_get_short_packet_buffer(struct
diff --git a/drivers/media/pci/intel/ipu-isys-csi2.h b/drivers/media/pci/intel/ipu-isys-csi2.h
index d7f2df3eb805..c4f4ea427a52 100644
--- a/drivers/media/pci/intel/ipu-isys-csi2.h
+++ b/drivers/media/pci/intel/ipu-isys-csi2.h
@@ -20,11 +20,7 @@ struct ipu_isys;
 #define CSI2_PAD_SINK			0
 #define NR_OF_CSI2_STREAMS		NR_OF_CSI2_VC
 #define NR_OF_CSI2_SOURCE_PADS		NR_OF_CSI2_STREAMS
-#define CSI2_PAD_SOURCE(n)		\
-	({ typeof(n) __n = (n);		\
-	(__n >= NR_OF_CSI2_SOURCE_PADS ? \
-		(NR_OF_CSI2_PADS - 2) : \
-		(__n + NR_OF_CSI2_SINK_PADS)); })
+#define CSI2_PAD_SOURCE			1
 #define NR_OF_CSI2_META_PADS		1
 #define NR_OF_CSI2_PADS			\
 	(NR_OF_CSI2_SINK_PADS + NR_OF_CSI2_SOURCE_PADS + NR_OF_CSI2_META_PADS)
@@ -89,8 +85,7 @@ struct ipu_isys_csi2 {
 	struct ipu_isys_csi2_pdata *pdata;
 	struct ipu_isys *isys;
 	struct ipu_isys_subdev asd;
-	struct ipu_isys_video av[NR_OF_CSI2_SOURCE_PADS];
-	struct ipu_isys_video av_meta;
+	struct ipu_isys_video av;
 	struct completion eof_completion;
 
 	void __iomem *base;
@@ -98,11 +93,8 @@ struct ipu_isys_csi2 {
 	unsigned int nlanes;
 	unsigned int index;
 	atomic_t sof_sequence;
-	bool in_frame[NR_OF_CSI2_VC];
-	bool wait_for_sync[NR_OF_CSI2_VC];
-
-	unsigned int remote_streams;
-	unsigned int stream_count;
+	bool in_frame;
+	bool wait_for_sync;
 
 	struct v4l2_ctrl *store_csi2_header;
 };
@@ -159,8 +151,8 @@ int ipu_isys_csi2_init(struct ipu_isys_csi2 *csi2,
 void ipu_isys_csi2_cleanup(struct ipu_isys_csi2 *csi2);
 struct ipu_isys_buffer *
 ipu_isys_csi2_get_short_packet_buffer(struct ipu_isys_pipeline *ip);
-void ipu_isys_csi2_sof_event(struct ipu_isys_csi2 *csi2, unsigned int vc);
-void ipu_isys_csi2_eof_event(struct ipu_isys_csi2 *csi2, unsigned int vc);
+void ipu_isys_csi2_sof_event(struct ipu_isys_csi2 *csi2);
+void ipu_isys_csi2_eof_event(struct ipu_isys_csi2 *csi2);
 void ipu_isys_csi2_wait_last_eof(struct ipu_isys_csi2 *csi2);
 
 /* interface for platform specific */
@@ -171,7 +163,6 @@ unsigned int ipu_isys_csi2_get_current_field(struct ipu_isys_pipeline *ip,
 					     unsigned int *timestamp);
 void ipu_isys_csi2_isr(struct ipu_isys_csi2 *csi2);
 void ipu_isys_csi2_error(struct ipu_isys_csi2 *csi2);
-bool ipu_isys_csi2_skew_cal_required(struct ipu_isys_csi2 *csi2);
 int ipu_isys_csi2_set_skew_cal(struct ipu_isys_csi2 *csi2, int enable);
 
 #endif /* IPU_ISYS_CSI2_H */
diff --git a/drivers/media/pci/intel/ipu-isys-queue.c b/drivers/media/pci/intel/ipu-isys-queue.c
index d95bee52fcb1..a5c7be30e24a 100644
--- a/drivers/media/pci/intel/ipu-isys-queue.c
+++ b/drivers/media/pci/intel/ipu-isys-queue.c
@@ -617,7 +617,7 @@ static int ipu_isys_stream_start(struct ipu_isys_pipeline *ip,
 					buf, to_dma_addr(msg),
 					sizeof(*buf),
 					IPU_FW_ISYS_SEND_TYPE_STREAM_CAPTURE);
-		ipu_put_fw_mgs_buffer(pipe_av->isys, (uintptr_t) buf);
+		ipu_put_fw_msg_buf(ip, (uintptr_t) buf);
 	} while (!WARN_ON(rval));
 
 	return 0;
@@ -738,7 +738,7 @@ static void __buf_queue(struct vb2_buffer *vb, bool force)
 				       buf, to_dma_addr(msg),
 				       sizeof(*buf),
 				       IPU_FW_ISYS_SEND_TYPE_STREAM_CAPTURE);
-	ipu_put_fw_mgs_buffer(pipe_av->isys, (uintptr_t) buf);
+	ipu_put_fw_msg_buf(ip, (uintptr_t) buf);
 	/*
 	 * FIXME: mark the buffers in the buffer list if the queue
 	 * operation fails.
@@ -1265,7 +1265,7 @@ ipu_isys_req_dispatch(struct media_device *mdev,
 				       ip->stream_handle,
 				       set, dma_addr, sizeof(*set),
 				       IPU_FW_ISYS_SEND_TYPE_STREAM_CAPTURE);
-	ipu_put_fw_mgs_buffer(pipe_av->isys, (uintptr_t) set);
+	ipu_put_fw_msg_buf(ip, (uintptr_t) set);
 
 	WARN_ON(rval);
 }
diff --git a/drivers/media/pci/intel/ipu-isys-subdev.c b/drivers/media/pci/intel/ipu-isys-subdev.c
index c67124bcd684..b3dc52796c38 100644
--- a/drivers/media/pci/intel/ipu-isys-subdev.c
+++ b/drivers/media/pci/intel/ipu-isys-subdev.c
@@ -148,19 +148,16 @@ u32 ipu_isys_subdev_code_to_uncompressed(u32 sink_code)
 }
 
 struct v4l2_mbus_framefmt *__ipu_isys_get_ffmt(struct v4l2_subdev *sd,
-			   struct v4l2_subdev_state *cfg,
+					       struct v4l2_subdev_state *state,
 					       unsigned int pad,
-					       unsigned int stream,
 					       unsigned int which)
 {
 	struct ipu_isys_subdev *asd = to_ipu_isys_subdev(sd);
 
 	if (which == V4L2_SUBDEV_FORMAT_ACTIVE)
-		return &asd->ffmt[pad][stream];
+		return &asd->ffmt[pad];
 	else
-		return v4l2_subdev_get_try_format(
-							 sd,
-							 cfg, pad);
+		return v4l2_subdev_state_get_format(state, pad);
 }
 
 struct v4l2_rect *__ipu_isys_get_selection(struct v4l2_subdev *sd,
@@ -248,7 +245,7 @@ int ipu_isys_subdev_fmt_propagate(struct v4l2_subdev *sd,
 	}
 
 	for (i = 0; i < sd->entity.num_pads; i++) {
-		ffmts[i] = __ipu_isys_get_ffmt(sd, cfg, i, 0, which);
+		ffmts[i] = __ipu_isys_get_ffmt(sd, cfg, i, which);
 		crops[i] = __ipu_isys_get_selection(
 			sd, cfg, V4L2_SEL_TGT_CROP, i, which);
 		compose[i] = __ipu_isys_get_selection(
@@ -383,14 +380,12 @@ int ipu_isys_subdev_set_ffmt_default(struct v4l2_subdev *sd,
 				      struct v4l2_subdev_format *fmt)
 {
 	struct v4l2_mbus_framefmt *ffmt =
-		__ipu_isys_get_ffmt(sd, cfg, fmt->pad, fmt->stream,
-					   fmt->which);
+		__ipu_isys_get_ffmt(sd, cfg, fmt->pad, fmt->which);
 
 	/* No propagation for non-zero pads. */
 	if (fmt->pad) {
 		struct v4l2_mbus_framefmt *sink_ffmt =
-			__ipu_isys_get_ffmt(sd, cfg, 0, fmt->stream,
-						   fmt->which);
+			__ipu_isys_get_ffmt(sd, cfg, 0, fmt->which);
 
 		ffmt->width = sink_ffmt->width;
 		ffmt->height = sink_ffmt->height;
@@ -414,8 +409,7 @@ int __ipu_isys_subdev_set_ffmt(struct v4l2_subdev *sd,
 {
 	struct ipu_isys_subdev *asd = to_ipu_isys_subdev(sd);
 	struct v4l2_mbus_framefmt *ffmt =
-		__ipu_isys_get_ffmt(sd, cfg, fmt->pad, fmt->stream,
-					   fmt->which);
+		__ipu_isys_get_ffmt(sd, cfg, fmt->pad, fmt->which);
 	u32 code = asd->supported_codes[fmt->pad][0];
 	unsigned int i;
 
@@ -470,7 +464,6 @@ int ipu_isys_subdev_get_ffmt(struct v4l2_subdev *sd,
 
 	mutex_lock(&asd->mutex);
 	fmt->format = *__ipu_isys_get_ffmt(sd, cfg, fmt->pad,
-					   fmt->stream,
 					   fmt->which);
 	mutex_unlock(&asd->mutex);
 
@@ -657,8 +650,7 @@ int ipu_isys_subdev_set_sel(struct v4l2_subdev *sd,
 	case V4L2_SEL_TGT_CROP:
 		if (pad->flags & MEDIA_PAD_FL_SINK) {
 			struct v4l2_mbus_framefmt *ffmt =
-				__ipu_isys_get_ffmt(sd, cfg, sel->pad, 0,
-							   sel->which);
+				__ipu_isys_get_ffmt(sd, cfg, sel->pad, sel->which);
 
 			__r.width = ffmt->width;
 			__r.height = ffmt->height;
@@ -886,12 +878,13 @@ int ipu_isys_subdev_init(struct ipu_isys_subdev *asd,
 			 struct v4l2_subdev_ops *ops,
 			 unsigned int nr_ctrls,
 			 unsigned int num_pads,
-			 unsigned int num_streams,
 			 unsigned int num_source,
 			 unsigned int num_sink,
-			 unsigned int sd_flags)
+			 unsigned int sd_flags,
+			 int src_pad_idx,
+			 int sink_pad_idx)
 {
-	int i;
+	unsigned int i;
 	int rval = -EINVAL;
 
 	mutex_init(&asd->mutex);
@@ -900,18 +893,29 @@ int ipu_isys_subdev_init(struct ipu_isys_subdev *asd,
 
 	asd->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | sd_flags;
 	asd->sd.owner = THIS_MODULE;
+	asd->sd.entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;
 
-	asd->nstreams = num_streams;
 	asd->nsources = num_source;
 	asd->nsinks = num_sink;
 
 	asd->pad = devm_kcalloc(&asd->isys->adev->dev, num_pads,
 				sizeof(*asd->pad), GFP_KERNEL);
 
-	asd->ffmt = (struct v4l2_mbus_framefmt **)
-			devm_kcalloc(&asd->isys->adev->dev, num_pads,
-				     sizeof(struct v4l2_mbus_framefmt *),
-				     GFP_KERNEL);
+	/*
+	 * Out of range IDX means that this particular type of pad
+	 * does not exist.
+	 */
+	if (src_pad_idx != ISYS_SUBDEV_NO_PAD) {
+		for (i = 0; i < num_source; i++)
+			asd->pad[src_pad_idx + i].flags = MEDIA_PAD_FL_SOURCE;
+	}
+	if (sink_pad_idx != ISYS_SUBDEV_NO_PAD) {
+		for (i = 0; i < num_sink; i++)
+			asd->pad[sink_pad_idx + i].flags = MEDIA_PAD_FL_SINK;
+	}
+
+	asd->ffmt = devm_kcalloc(&asd->isys->adev->dev, num_pads,
+				 sizeof(*asd->ffmt), GFP_KERNEL);
 
 	asd->crop = devm_kcalloc(&asd->isys->adev->dev, num_pads,
 				 sizeof(*asd->crop), GFP_KERNEL);
@@ -921,30 +925,10 @@ int ipu_isys_subdev_init(struct ipu_isys_subdev *asd,
 
 	asd->valid_tgts = devm_kcalloc(&asd->isys->adev->dev, num_pads,
 				       sizeof(*asd->valid_tgts), GFP_KERNEL);
-	asd->route = devm_kcalloc(&asd->isys->adev->dev, num_streams,
-				  sizeof(*asd->route), GFP_KERNEL);
-
-	asd->stream = devm_kcalloc(&asd->isys->adev->dev, num_pads,
-				   sizeof(*asd->stream), GFP_KERNEL);
-
 	if (!asd->pad || !asd->ffmt || !asd->crop || !asd->compose ||
-	    !asd->valid_tgts || !asd->route || !asd->stream)
+	    !asd->valid_tgts)
 		return -ENOMEM;
 
-	for (i = 0; i < num_pads; i++) {
-		asd->ffmt[i] = (struct v4l2_mbus_framefmt *)
-		    devm_kcalloc(&asd->isys->adev->dev, num_streams,
-				 sizeof(struct v4l2_mbus_framefmt), GFP_KERNEL);
-		if (!asd->ffmt[i])
-			return -ENOMEM;
-
-		asd->stream[i].stream_id =
-		    devm_kcalloc(&asd->isys->adev->dev, num_source,
-				 sizeof(*asd->stream[i].stream_id), GFP_KERNEL);
-		if (!asd->stream[i].stream_id)
-			return -ENOMEM;
-	}
-
 	rval = media_entity_pads_init(&asd->sd.entity, num_pads, asd->pad);
 	if (rval)
 		goto out_mutex_destroy;
diff --git a/drivers/media/pci/intel/ipu-isys-subdev.h b/drivers/media/pci/intel/ipu-isys-subdev.h
index 1cbf82858bf5..5b514f7e0d39 100644
--- a/drivers/media/pci/intel/ipu-isys-subdev.h
+++ b/drivers/media/pci/intel/ipu-isys-subdev.h
@@ -68,26 +68,16 @@ struct ipu_isys_subdev {
 	struct ipu_isys *isys;
 	u32 const *const *supported_codes;
 	struct media_pad *pad;
-	struct v4l2_mbus_framefmt **ffmt;
+	struct v4l2_mbus_framefmt *ffmt;
 	struct v4l2_rect *crop;
 	struct v4l2_rect *compose;
-	struct {
-		unsigned int *stream_id;
-		 DECLARE_BITMAP(streams_stat, 32);
-	} *stream;	/* stream enable/disable status, indexed by pad */
-	struct {
-		unsigned int sink;
-		unsigned int source;
-		int flags;
-	} *route;	/* pad level info, indexed by stream */
-	unsigned int nstreams;
 	unsigned int nsinks;
 	unsigned int nsources;
 	struct v4l2_ctrl_handler ctrl_handler;
 	void (*ctrl_init)(struct v4l2_subdev *sd);
 	void (*set_ffmt)(struct v4l2_subdev *sd,
-	      struct v4l2_subdev_state *cfg,
-			  struct v4l2_subdev_format *fmt);
+			 struct v4l2_subdev_state *state,
+			 struct v4l2_subdev_format *fmt);
 	struct {
 		bool crop;
 		bool compose;
@@ -101,9 +91,8 @@ struct ipu_isys_subdev {
 	container_of(__sd, struct ipu_isys_subdev, sd)
 
 struct v4l2_mbus_framefmt *__ipu_isys_get_ffmt(struct v4l2_subdev *sd,
-			   struct v4l2_subdev_state *cfg,
+					       struct v4l2_subdev_state *state,
 					       unsigned int pad,
-					       unsigned int stream,
 					       unsigned int which);
 
 unsigned int ipu_isys_mbus_code_to_bpp(u32 code);
@@ -153,14 +142,18 @@ int ipu_isys_subdev_link_validate(struct v4l2_subdev *sd,
 
 int ipu_isys_subdev_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh);
 int ipu_isys_subdev_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh);
+
+#define ISYS_SUBDEV_NO_PAD	(-1)
+
 int ipu_isys_subdev_init(struct ipu_isys_subdev *asd,
 			 struct v4l2_subdev_ops *ops,
 			 unsigned int nr_ctrls,
 			 unsigned int num_pads,
-			 unsigned int num_streams,
 			 unsigned int num_source,
 			 unsigned int num_sink,
-			 unsigned int sd_flags);
+			 unsigned int sd_flags,
+			 int src_pad_idx,
+			 int sink_pad_idx);
 void ipu_isys_subdev_cleanup(struct ipu_isys_subdev *asd);
 int ipu_isys_subdev_get_frame_desc(struct v4l2_subdev *sd,
 				   struct v4l2_mbus_frame_desc *desc);
diff --git a/drivers/media/pci/intel/ipu-isys-tpg.c b/drivers/media/pci/intel/ipu-isys-tpg.c
index 59151f3954ab..1c837ccee419 100644
--- a/drivers/media/pci/intel/ipu-isys-tpg.c
+++ b/drivers/media/pci/intel/ipu-isys-tpg.c
@@ -171,8 +171,7 @@ static void tpg_set_ffmt(struct v4l2_subdev *sd,
 			 struct v4l2_subdev_format *fmt)
 {
 	fmt->format.field = V4L2_FIELD_NONE;
-	*__ipu_isys_get_ffmt(sd, cfg, fmt->pad, fmt->stream,
-			     fmt->which) = fmt->format;
+	*__ipu_isys_get_ffmt(sd, cfg, fmt->pad, fmt->which) = fmt->format;
 }
 
 static int ipu_isys_tpg_set_ffmt(struct v4l2_subdev *sd,
diff --git a/drivers/media/pci/intel/ipu-isys-video.c b/drivers/media/pci/intel/ipu-isys-video.c
index ae7dabd1e3a4..5f347b203e5f 100644
--- a/drivers/media/pci/intel/ipu-isys-video.c
+++ b/drivers/media/pci/intel/ipu-isys-video.c
@@ -1391,6 +1391,93 @@ static int media_pipeline_start_by_vc(struct ipu_isys_video *av,
 	return ret;
 }
 
+void
+ipu_isys_prepare_fw_cfg_default(struct ipu_isys_video *av,
+				struct ipu_fw_isys_stream_cfg_data_abi *cfg)
+{
+	struct media_pipeline *mp = media_entity_pipeline(&av->vdev.entity);
+	struct ipu_isys_pipeline *ip = to_ipu_isys_pipeline(mp);
+	struct ipu_isys_queue *aq = &av->aq;
+	struct ipu_fw_isys_output_pin_info_abi *pin_info;
+	struct ipu_isys *isys = av->isys;
+	unsigned int type_index, type;
+	int pin = cfg->nof_output_pins++;
+
+	aq->fw_output = pin;
+	ip->output_pins[pin].pin_ready = ipu_isys_queue_buf_ready;
+	ip->output_pins[pin].aq = aq;
+
+	pin_info = &cfg->output_pins[pin];
+	pin_info->input_pin_id = 0;
+	pin_info->output_res.width = av->mpix.width;
+	pin_info->output_res.height = av->mpix.height;
+
+	if (!av->pfmt->bpp_planar)
+		pin_info->stride = av->mpix.plane_fmt[0].bytesperline;
+	else
+		pin_info->stride = ALIGN(DIV_ROUND_UP(av->mpix.width *
+						      av->pfmt->bpp_planar,
+						      BITS_PER_BYTE),
+					 av->isys->line_align);
+
+	pin_info->pt = aq->css_pin_type;
+	pin_info->ft = av->pfmt->css_pixelformat;
+	pin_info->send_irq = 1;
+	memset(pin_info->ts_offsets, 0, sizeof(pin_info->ts_offsets));
+	pin_info->s2m_pixel_soc_pixel_remapping =
+	    S2M_PIXEL_SOC_PIXEL_REMAPPING_FLAG_NO_REMAPPING;
+	pin_info->csi_be_soc_pixel_remapping =
+	    CSI_BE_SOC_PIXEL_REMAPPING_FLAG_NO_REMAPPING;
+	cfg->vc = 0;
+
+	switch (pin_info->pt) {
+	/* non-snoopable sensor data to PSYS */
+	case IPU_FW_ISYS_PIN_TYPE_RAW_NS:
+		type_index = IPU_FW_ISYS_VC1_SENSOR_DATA;
+		pin_info->sensor_type = isys->sensor_types[type_index]++;
+		pin_info->snoopable = false;
+		pin_info->error_handling_enable = false;
+		type = isys->sensor_types[type_index];
+		if (type > isys->sensor_info.vc1_data_end)
+			isys->sensor_types[type_index] =
+				isys->sensor_info.vc1_data_start;
+
+		break;
+	/* snoopable META/Stats data to CPU */
+	case IPU_FW_ISYS_PIN_TYPE_METADATA_0:
+	case IPU_FW_ISYS_PIN_TYPE_METADATA_1:
+		pin_info->sensor_type = isys->sensor_info.sensor_metadata;
+		pin_info->snoopable = true;
+		pin_info->error_handling_enable = false;
+		break;
+	case IPU_FW_ISYS_PIN_TYPE_RAW_SOC:
+	case IPU_FW_ISYS_PIN_TYPE_MIPI:
+		type_index = IPU_FW_ISYS_VC1_SENSOR_DATA;
+		pin_info->sensor_type = isys->sensor_types[type_index]++;
+		pin_info->snoopable = false;
+		pin_info->error_handling_enable = false;
+		type = isys->sensor_types[type_index];
+		if (type > isys->sensor_info.vc1_data_end)
+			isys->sensor_types[type_index] =
+				isys->sensor_info.vc1_data_start;
+
+		break;
+
+	default:
+		dev_err(&av->isys->adev->dev,
+			"Unknown pin type, use metadata type as default\n");
+
+		pin_info->sensor_type = isys->sensor_info.sensor_metadata;
+		pin_info->snoopable = true;
+		pin_info->error_handling_enable = false;
+	}
+	if (av->compression) {
+		pin_info->payload_buf_size = av->mpix.plane_fmt[0].sizeimage;
+		pin_info->reserve_compression = av->compression;
+		pin_info->ts_offsets[0] = av->ts_offsets[0];
+	}
+}
+
 static unsigned int ipu_isys_get_compression_scheme(u32 code)
 {
 	switch (code) {
@@ -1566,7 +1653,7 @@ static int start_stream_firmware(struct ipu_isys_video *av,
 				       to_dma_addr(msg),
 				       sizeof(*stream_cfg),
 				       IPU_FW_ISYS_SEND_TYPE_STREAM_OPEN);
-	ipu_put_fw_mgs_buffer(av->isys, (uintptr_t) stream_cfg);
+	ipu_put_fw_msg_buf(ip, (uintptr_t) stream_cfg);
 
 	if (rval < 0) {
 		dev_err(dev, "can't open stream (%d)\n", rval);
@@ -1621,7 +1708,7 @@ static int start_stream_firmware(struct ipu_isys_video *av,
 				buf, to_dma_addr(msg),
 				sizeof(*buf),
 				IPU_FW_ISYS_SEND_TYPE_STREAM_START_AND_CAPTURE);
-		ipu_put_fw_mgs_buffer(av->isys, (uintptr_t) buf);
+		ipu_put_fw_msg_buf(ip, (uintptr_t) buf);
 	} else {
 		rval = ipu_fw_isys_simple_cmd(av->isys,
 					ip->stream_handle,
@@ -1904,14 +1991,26 @@ int ipu_isys_video_set_streaming(struct ipu_isys_video *av,
 	struct media_entity_enum entities;
 
 	struct media_entity *entity, *entity2;
-	struct ipu_isys_pipeline *ip =
-	    to_ipu_isys_pipeline(media_entity_pipeline(&av->vdev.entity));
+	struct media_pipeline *mp = media_entity_pipeline(&av->vdev.entity);
+	struct ipu_isys_pipeline *ip = to_ipu_isys_pipeline(mp);
 	struct v4l2_subdev *sd, *esd;
 	int rval = 0;
 
 	dev_dbg(dev, "set stream: %d\n", state);
 
+	if (!ip) {
+		dev_err(dev, "%s no pipeline found for %s\n", __func__,
+			av->vdev.name);
+		return -ENODEV;
+	}
+
+	if (!ip->external) {
+		dev_err(dev, "no media pad found for %s\n", av->vdev.name);
+		return -ENODEV;
+	}
+
 	if (!ip->external->entity) {
+		dev_err(dev, "no entify found for %s\n", av->vdev.name);
 		WARN_ON(1);
 		return -ENODEV;
 	}
@@ -1930,41 +2029,31 @@ int ipu_isys_video_set_streaming(struct ipu_isys_video *av,
 		stop_streaming_firmware(av);
 
 		/* stop external sub-device now. */
-		dev_err(dev, "s_stream %s (ext)\n", ip->external->entity->name);
+		dev_info(dev, "stream off %s\n", ip->external->entity->name);
 
-		if (ip->csi2) {
-			if (ip->csi2->stream_count == 1) {
-				v4l2_subdev_call(esd, video, s_stream, state);
-#if defined(CONFIG_VIDEO_INTEL_IPU4) || defined(CONFIG_VIDEO_INTEL_IPU4P)
-				ipu_isys_csi2_wait_last_eof(ip->csi2);
-#endif
-			}
-		} else {
-			v4l2_subdev_call(esd, video, s_stream, state);
-		}
+		v4l2_subdev_call(esd, video, s_stream, state);
 	}
 
 	mutex_lock(&mdev->graph_mutex);
 
 	media_graph_walk_start(&ip->graph,
-				      &av->vdev.entity);
+			       &av->vdev.entity);
 
 	while ((entity = media_graph_walk_next(&ip->graph))) {
 		sd = media_entity_to_v4l2_subdev(entity);
 
-		dev_dbg(dev, "set stream: entity %s\n", entity->name);
-
 		/* Non-subdev nodes can be safely ignored here. */
 		if (!is_media_entity_v4l2_subdev(entity))
 			continue;
 
 		/* Don't start truly external devices quite yet. */
 		if (strncmp(sd->name, IPU_ISYS_ENTITY_PREFIX,
-			strlen(IPU_ISYS_ENTITY_PREFIX)) != 0 ||
-			ip->external->entity == entity)
+			    strlen(IPU_ISYS_ENTITY_PREFIX)) != 0 ||
+		    ip->external->entity == entity)
 			continue;
 
-		dev_dbg(dev, "s_stream %s\n", entity->name);
+		dev_dbg(dev, "s_stream %s entity %s\n", state ? "on" : "off",
+			entity->name);
 		rval = v4l2_subdev_call(sd, video, s_stream, state);
 		if (!state)
 			continue;
@@ -1978,34 +2067,29 @@ int ipu_isys_video_set_streaming(struct ipu_isys_video *av,
 
 	mutex_unlock(&mdev->graph_mutex);
 
+	if (av->aq.css_pin_type == IPU_FW_ISYS_PIN_TYPE_RAW_SOC) {
+		if (state)
+			configure_stream_watermark(av);
+		update_stream_watermark(av, state);
+	}
+
 	/* Oh crap */
 	if (state) {
-		if (ipu_isys_csi2_skew_cal_required(ip->csi2) &&
-		    ip->csi2->remote_streams == ip->csi2->stream_count)
-			perform_skew_cal(ip);
-
 		rval = start_stream_firmware(av, bl);
 		if (rval)
-			goto out_media_entity_stop_streaming;
+			goto out_update_stream_watermark;
 
 		dev_dbg(dev, "set stream: source %d, stream_handle %d\n",
 			ip->source, ip->stream_handle);
 
 		/* Start external sub-device now. */
-		dev_dbg(dev, "set stream: s_stream %s (ext)\n",
-			ip->external->entity->name);
-
-		if (ip->csi2 &&
-		    ip->csi2->remote_streams == ip->csi2->stream_count)
-			rval = v4l2_subdev_call(esd, video, s_stream, state);
-		else if (!ip->csi2)
-			rval = v4l2_subdev_call(esd, video, s_stream, state);
+		dev_info(dev, "stream on %s\n", ip->external->entity->name);
+
+		rval = v4l2_subdev_call(esd, video, s_stream, state);
 		if (rval)
 			goto out_media_entity_stop_streaming_firmware;
 	} else {
 		close_streaming_firmware(av);
-		av->ip.stream_id = 0;
-		av->ip.vc = 0;
 	}
 
 	if (state)
@@ -2019,11 +2103,15 @@ int ipu_isys_video_set_streaming(struct ipu_isys_video *av,
 out_media_entity_stop_streaming_firmware:
 	stop_streaming_firmware(av);
 
+out_update_stream_watermark:
+	if (av->aq.css_pin_type == IPU_FW_ISYS_PIN_TYPE_RAW_SOC)
+		update_stream_watermark(av, 0);
+
 out_media_entity_stop_streaming:
 	mutex_lock(&mdev->graph_mutex);
 
 	media_graph_walk_start(&ip->graph,
-				      &av->vdev.entity);
+			       &av->vdev.entity);
 
 	while (state && (entity2 = media_graph_walk_next(&ip->graph)) &&
 	       entity2 != entity) {
diff --git a/drivers/media/pci/intel/ipu-isys-video.h b/drivers/media/pci/intel/ipu-isys-video.h
index a0612f7eb512..3320dbd87794 100644
--- a/drivers/media/pci/intel/ipu-isys-video.h
+++ b/drivers/media/pci/intel/ipu-isys-video.h
@@ -68,7 +68,6 @@ struct ipu_isys_pipeline {
 	struct media_pipeline pipe;
 	struct media_pad *external;
 	atomic_t sequence;
-	int last_sequence;
 	unsigned int seq_index;
 	struct sequence_info seq[IPU_ISYS_MAX_PARALLEL_SOF];
 	int source;	/* SSI stream source */
@@ -78,12 +77,11 @@ struct ipu_isys_pipeline {
 	struct ipu_isys_csi2_be *csi2_be;
 	struct ipu_isys_csi2_be_soc *csi2_be_soc;
 	struct ipu_isys_csi2 *csi2;
-	struct ipu_isys_tpg *tpg;
+
 	/*
 	 * Number of capture queues, write access serialised using struct
 	 * ipu_isys.stream_mutex
 	 */
-	/* If it supports vc, this is number of links for the same vc. */
 	int nr_queues;
 	int nr_streaming;	/* Number of capture queues streaming */
 	int streaming;	/* Has streaming been really started? */
@@ -92,9 +90,12 @@ struct ipu_isys_pipeline {
 	struct completion stream_close_completion;
 	struct completion stream_start_completion;
 	struct completion stream_stop_completion;
-	struct completion capture_ack_completion;
 	struct ipu_isys *isys;
 
+	spinlock_t listlock;	/* Protect framebuflist */
+	struct list_head framebuflist;
+	struct list_head framebuflist_fw;
+
 	void (*capture_done[IPU_NUM_CAPTURE_DONE])
 	 (struct ipu_isys_pipeline *ip,
 	  struct ipu_fw_isys_resp_info_abi *resp);
@@ -113,16 +114,24 @@ struct ipu_isys_pipeline {
 	spinlock_t short_packet_queue_lock;
 	struct list_head pending_interlaced_bufs;
 	unsigned int short_packet_trace_index;
-	unsigned int vc;
-	unsigned int stream_id;
 	struct media_graph graph;
 	struct media_entity_enum entity_enum;
-	struct ipu_isys_sub_stream_vc asv[CSI2_BE_SOC_SOURCE_PADS_NUM];
 };
 
 #define to_ipu_isys_pipeline(__pipe)				\
 	container_of((__pipe), struct ipu_isys_pipeline, pipe)
 
+struct video_stream_watermark {
+	u32 width;
+	u32 height;
+	u32 vblank;
+	u32 hblank;
+	u32 frame_rate;
+	u64 pixel_rate;
+	u64 stream_data_rate;
+	struct list_head stream_node;
+};
+
 struct ipu_isys_video {
 	/* Serialise access to other fields in the struct. */
 	struct mutex mutex;
@@ -136,13 +145,21 @@ struct ipu_isys_video {
 	struct ipu_isys_pipeline ip;
 	unsigned int streaming;
 	bool packed;
+	bool compression;
+	bool initialized;
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct v4l2_ctrl *compression_ctrl;
+	unsigned int ts_offsets[VIDEO_MAX_PLANES];
 	unsigned int line_header_length;	/* bits */
 	unsigned int line_footer_length;	/* bits */
-	const struct ipu_isys_pixelformat *(*try_fmt_vid_mplane)(
-		struct ipu_isys_video *av,
-		struct v4l2_pix_format_mplane *mpix);
-	void (*prepare_firmware_stream_cfg)(struct ipu_isys_video *av,
-		struct ipu_fw_isys_stream_cfg_data_abi *cfg);
+
+	struct video_stream_watermark *watermark;
+
+	const struct ipu_isys_pixelformat *
+		(*try_fmt_vid_mplane)(struct ipu_isys_video *av,
+				      struct v4l2_pix_format_mplane *mpix);
+	void (*prepare_fw_stream)(struct ipu_isys_video *av,
+				  struct ipu_fw_isys_stream_cfg_data_abi *cfg);
 };
 
 #define ipu_isys_queue_to_video(__aq) \
@@ -170,6 +187,10 @@ ipu_isys_video_try_fmt_vid_mplane(struct ipu_isys_video *av,
 				  struct v4l2_pix_format_mplane *mpix,
 				  int store_csi2_header);
 
+void
+ipu_isys_prepare_fw_cfg_default(struct ipu_isys_video *av,
+				struct ipu_fw_isys_stream_cfg_data_abi *cfg);
+
 void ipu_isys_prepare_firmware_stream_cfg_default(
 	struct ipu_isys_video *av,
 	struct ipu_fw_isys_stream_cfg_data_abi *cfg);
diff --git a/drivers/media/pci/intel/ipu-isys.c b/drivers/media/pci/intel/ipu-isys.c
index df9a101ba868..96a8b42ba8d9 100644
--- a/drivers/media/pci/intel/ipu-isys.c
+++ b/drivers/media/pci/intel/ipu-isys.c
@@ -204,58 +204,25 @@ static void isys_register_ext_subdevs(struct ipu_isys *isys)
 
 static void isys_unregister_subdevices(struct ipu_isys *isys)
 {
-	const struct ipu_isys_internal_tpg_pdata *tpg =
-	    &isys->pdata->ipdata->tpg;
 	const struct ipu_isys_internal_csi2_pdata *csi2 =
 	    &isys->pdata->ipdata->csi2;
 	unsigned int i;
 
-	ipu_isys_csi2_be_cleanup(&isys->csi2_be);
-	ipu_isys_csi2_be_soc_cleanup(&isys->csi2_be_soc);
+	for (i = 0; i < NR_OF_CSI2_BE_SOC_DEV; i++)
+		ipu_isys_csi2_be_soc_cleanup(&isys->csi2_be_soc[i]);
 
-	ipu_isys_isa_cleanup(&isys->isa);
-
-	for (i = 0; i < tpg->ntpgs; i++)
-		ipu_isys_tpg_cleanup(&isys->tpg[i]);
-
-	for (i = 0; i < csi2->nports; i++)
+	for (i = 0; i < csi2->nports && isys->csi2; i++)
 		ipu_isys_csi2_cleanup(&isys->csi2[i]);
 }
 
 static int isys_register_subdevices(struct ipu_isys *isys)
 {
-	const struct ipu_isys_internal_tpg_pdata *tpg =
-	    &isys->pdata->ipdata->tpg;
 	const struct ipu_isys_internal_csi2_pdata *csi2 =
 	    &isys->pdata->ipdata->csi2;
-	struct ipu_isys_subdev_pdata *spdata = isys->pdata->spdata;
-	struct ipu_isys_subdev_info **sd_info;
-	DECLARE_BITMAP(csi2_enable, 32);
-	unsigned int i, j, k;
+	struct ipu_isys_csi2_be_soc *csi2_be_soc;
+	unsigned int i, k;
 	int rval;
 
-	/*
-	 * Here is somewhat a workaround, let each platform decide
-	 * if csi2 port can be optimized, which means only registered
-	 * port from pdata would be enabled.
-	 */
-	if (csi2_port_optimized && spdata) {
-		bitmap_zero(csi2_enable, 32);
-		for (sd_info = spdata->subdevs; *sd_info; sd_info++) {
-			if ((*sd_info)->csi2) {
-				i = (*sd_info)->csi2->port;
-				if (i >= csi2->nports) {
-					dev_warn(&isys->adev->dev,
-						 "invalid csi2 port %u\n", i);
-					continue;
-				}
-				bitmap_set(csi2_enable, i, 1);
-			}
-		}
-	} else {
-		bitmap_fill(csi2_enable, 32);
-	}
-
 	isys->csi2 = devm_kcalloc(&isys->adev->dev, csi2->nports,
 				  sizeof(*isys->csi2), GFP_KERNEL);
 	if (!isys->csi2) {
@@ -264,9 +231,6 @@ static int isys_register_subdevices(struct ipu_isys *isys)
 	}
 
 	for (i = 0; i < csi2->nports; i++) {
-		if (!test_bit(i, csi2_enable))
-			continue;
-
 		rval = ipu_isys_csi2_init(&isys->csi2[i], isys,
 					  isys->pdata->base +
 					  csi2->offsets[i], i);
@@ -276,111 +240,32 @@ static int isys_register_subdevices(struct ipu_isys *isys)
 		isys->isr_csi2_bits |= IPU_ISYS_UNISPART_IRQ_CSI2(i);
 	}
 
-	isys->tpg = devm_kcalloc(&isys->adev->dev, tpg->ntpgs,
-				 sizeof(*isys->tpg), GFP_KERNEL);
-	if (!isys->tpg) {
-		rval = -ENOMEM;
-		goto fail;
-	}
-
-	for (i = 0; i < tpg->ntpgs; i++) {
-		rval = ipu_isys_tpg_init(&isys->tpg[i], isys,
-					 isys->pdata->base +
-					 tpg->offsets[i],
-					 tpg->sels ? (isys->pdata->base +
-						      tpg->sels[i]) : NULL, i);
-		if (rval)
-			goto fail;
-	}
-
-	rval = ipu_isys_csi2_be_soc_init(&isys->csi2_be_soc, isys);
-	if (rval) {
-		dev_info(&isys->adev->dev,
-			 "can't register soc csi2 be device\n");
-		goto fail;
-	}
-
-	rval = ipu_isys_csi2_be_init(&isys->csi2_be, isys);
-	if (rval) {
-		dev_info(&isys->adev->dev,
-			 "can't register raw csi2 be device\n");
-		goto fail;
-	}
-	rval = ipu_isys_isa_init(&isys->isa, isys, NULL);
-	if (rval) {
-		dev_info(&isys->adev->dev, "can't register isa device\n");
-		goto fail;
-	}
-
-	for (i = 0; i < csi2->nports; i++) {
-		if (!test_bit(i, csi2_enable))
-			continue;
-
-		for (j = CSI2_PAD_SOURCE(0);
-		     j < (NR_OF_CSI2_SOURCE_PADS + CSI2_PAD_SOURCE(0)); j++) {
-			rval =
-			    media_create_pad_link(&isys->csi2[i].asd.sd.entity,
-						  j,
-						  &isys->csi2_be.asd.sd.entity,
-						  CSI2_BE_PAD_SINK, 0);
-			if (rval) {
-				dev_info(&isys->adev->dev,
-					 "can't create link csi2 <=> csi2_be\n");
-				goto fail;
-			}
-
-			for (k = CSI2_BE_SOC_PAD_SINK(0);
-			     k < NR_OF_CSI2_BE_SOC_SINK_PADS; k++) {
-				rval =
-				    media_create_pad_link(&isys->csi2[i].asd.sd.
-							  entity, j,
-							  &isys->csi2_be_soc.
-							  asd.sd.entity, k,
-							  MEDIA_LNK_FL_DYNAMIC);
-				if (rval) {
-					dev_info(&isys->adev->dev,
-						 "can't create link csi2->be_soc\n");
-					goto fail;
-				}
-			}
-		}
-	}
-
-	for (i = 0; i < tpg->ntpgs; i++) {
-		rval = media_create_pad_link(&isys->tpg[i].asd.sd.entity,
-					     TPG_PAD_SOURCE,
-					     &isys->csi2_be.asd.sd.entity,
-					     CSI2_BE_PAD_SINK, 0);
+	for (k = 0; k < NR_OF_CSI2_BE_SOC_DEV; k++) {
+		rval = ipu_isys_csi2_be_soc_init(&isys->csi2_be_soc[k],
+						 isys, k);
 		if (rval) {
 			dev_info(&isys->adev->dev,
-				 "can't create link between tpg and csi2_be\n");
+				 "can't register csi2 soc be device %d\n", k);
 			goto fail;
 		}
+	}
 
-		for (k = CSI2_BE_SOC_PAD_SINK(0);
-		     k < NR_OF_CSI2_BE_SOC_SINK_PADS; k++) {
+	for (i = 0; i < csi2->nports; i++) {
+		for (k = 0; k < NR_OF_CSI2_BE_SOC_DEV; k++) {
+			csi2_be_soc = &isys->csi2_be_soc[k];
 			rval =
-			    media_create_pad_link(&isys->tpg[i].asd.sd.entity,
-						  TPG_PAD_SOURCE,
-						  &isys->csi2_be_soc.asd.sd.
-						  entity, k,
-						  MEDIA_LNK_FL_DYNAMIC);
+			    media_create_pad_link(&isys->csi2[i].asd.sd.entity,
+						  CSI2_PAD_SOURCE,
+						  &csi2_be_soc->asd.sd.entity,
+						  CSI2_BE_SOC_PAD_SINK, 0);
 			if (rval) {
 				dev_info(&isys->adev->dev,
-					 "can't create link tpg->be_soc\n");
+					 "can't create link csi2->be_soc\n");
 				goto fail;
 			}
 		}
 	}
 
-	rval = media_create_pad_link(&isys->csi2_be.asd.sd.entity,
-				     CSI2_BE_PAD_SOURCE,
-				     &isys->isa.asd.sd.entity, ISA_PAD_SINK, 0);
-	if (rval) {
-		dev_info(&isys->adev->dev,
-			 "can't create link between CSI2 raw be and ISA\n");
-		goto fail;
-	}
 	return 0;
 
 fail:
@@ -395,6 +280,42 @@ static struct media_device_ops isys_mdev_ops = {
 	.req_queue = ipu_isys_req_queue,
 };
 
+static int isys_iwake_watermark_init(struct ipu_isys *isys)
+{
+	struct isys_iwake_watermark *iwake_watermark;
+
+	if (isys->iwake_watermark)
+		return 0;
+
+	iwake_watermark = devm_kzalloc(&isys->adev->dev,
+				       sizeof(*iwake_watermark), GFP_KERNEL);
+	if (!iwake_watermark)
+		return -ENOMEM;
+	INIT_LIST_HEAD(&iwake_watermark->video_list);
+	mutex_init(&iwake_watermark->mutex);
+
+	iwake_watermark->ltrdid.lut_ltr.value = 0;
+	isys->iwake_watermark = iwake_watermark;
+	iwake_watermark->isys = isys;
+	iwake_watermark->iwake_enabled = false;
+	iwake_watermark->force_iwake_disable = false;
+	return 0;
+}
+
+static int isys_iwake_watermark_cleanup(struct ipu_isys *isys)
+{
+	struct isys_iwake_watermark *iwake_watermark = isys->iwake_watermark;
+
+	if (!iwake_watermark)
+		return -EINVAL;
+	mutex_lock(&iwake_watermark->mutex);
+	list_del(&iwake_watermark->video_list);
+	mutex_unlock(&iwake_watermark->mutex);
+	mutex_destroy(&iwake_watermark->mutex);
+	isys->iwake_watermark = NULL;
+	return 0;
+}
+
 /* The .bound() notifier callback when a match is found */
 static int isys_notifier_bound(struct v4l2_async_notifier *notifier,
 			       struct v4l2_subdev *sd,
@@ -677,29 +598,19 @@ static void isys_remove(struct ipu_bus_device *adev)
 {
 	struct ipu_isys *isys = ipu_bus_get_drvdata(adev);
 	struct ipu_device *isp = adev->isp;
-	struct isys_fw_msgs *fwmsg, *safe;
 
 	dev_info(&adev->dev, "removed\n");
+#ifdef CONFIG_DEBUG_FS
 	if (isp->ipu_dir)
 		debugfs_remove_recursive(isys->debugfsdir);
+#endif
 
-	list_for_each_entry_safe(fwmsg, safe, &isys->framebuflist, head) {
-		dma_free_attrs(&adev->dev, sizeof(struct isys_fw_msgs),
-			       fwmsg, fwmsg->dma_addr,
-			       0
-		    );
-	}
-
-	list_for_each_entry_safe(fwmsg, safe, &isys->framebuflist_fw, head) {
-		dma_free_attrs(&adev->dev, sizeof(struct isys_fw_msgs),
-			       fwmsg, fwmsg->dma_addr,
-			       0
-		    );
-	}
+	isys_iwake_watermark_cleanup(isys);
 
 	ipu_trace_uninit(&adev->dev);
-	isys_unregister_devices(isys);
 	isys_notifier_cleanup(isys);
+	isys_unregister_devices(isys);
+
 	cpu_latency_qos_remove_request(&isys->pm_qos);
 
 	if (!isp->secure_mode) {
@@ -715,10 +626,10 @@ static void isys_remove(struct ipu_bus_device *adev)
 
 	if (isys->short_packet_source == IPU_ISYS_SHORT_PACKET_FROM_TUNIT) {
 		u32 trace_size = IPU_ISYS_SHORT_PACKET_TRACE_BUFFER_SIZE;
-		unsigned long attrs = 0;
-		dma_free_attrs(&adev->dev, trace_size,
-			       isys->short_packet_trace_buffer,
-			       isys->short_packet_trace_buffer_dma_addr, attrs);
+
+		dma_free_coherent(&adev->dev, trace_size,
+				  isys->short_packet_trace_buffer,
+				  isys->short_packet_trace_buffer_dma_addr);
 	}
 }
 
@@ -769,43 +680,46 @@ static int ipu_isys_init_debugfs(struct ipu_isys *isys)
 	return -ENOMEM;
 }
 
-static int alloc_fw_msg_buffers(struct ipu_isys *isys, int amount)
+static int alloc_fw_msg_bufs(struct ipu_isys_pipeline *ip, int amount)
 {
+	struct ipu_isys_video *pipe_av =
+		container_of(ip, struct ipu_isys_video, ip);
+	struct ipu_isys *isys;
 	dma_addr_t dma_addr;
 	struct isys_fw_msgs *addr;
 	unsigned int i;
 	unsigned long flags;
 
+	isys = pipe_av->isys;
+
 	for (i = 0; i < amount; i++) {
 		addr = dma_alloc_attrs(&isys->adev->dev,
 				       sizeof(struct isys_fw_msgs),
 				       &dma_addr, GFP_KERNEL,
-				       0
-		    );
+				       0);
 		if (!addr)
 			break;
 		addr->dma_addr = dma_addr;
 
-		spin_lock_irqsave(&isys->listlock, flags);
-		list_add(&addr->head, &isys->framebuflist);
-		spin_unlock_irqrestore(&isys->listlock, flags);
+		spin_lock_irqsave(&ip->listlock, flags);
+		list_add(&addr->head, &ip->framebuflist);
+		spin_unlock_irqrestore(&ip->listlock, flags);
 	}
 	if (i == amount)
 		return 0;
-	spin_lock_irqsave(&isys->listlock, flags);
-	while (!list_empty(&isys->framebuflist)) {
-		addr = list_first_entry(&isys->framebuflist,
+	spin_lock_irqsave(&ip->listlock, flags);
+	while (!list_empty(&ip->framebuflist)) {
+		addr = list_first_entry(&ip->framebuflist,
 					struct isys_fw_msgs, head);
 		list_del(&addr->head);
-		spin_unlock_irqrestore(&isys->listlock, flags);
+		spin_unlock_irqrestore(&ip->listlock, flags);
 		dma_free_attrs(&isys->adev->dev,
 			       sizeof(struct isys_fw_msgs),
 			       addr, addr->dma_addr,
-			       0
-		    );
-		spin_lock_irqsave(&isys->listlock, flags);
+			       0);
+		spin_lock_irqsave(&ip->listlock, flags);
 	}
-	spin_unlock_irqrestore(&isys->listlock, flags);
+	spin_unlock_irqrestore(&ip->listlock, flags);
 	return -ENOMEM;
 }
 
@@ -819,23 +733,23 @@ struct isys_fw_msgs *ipu_get_fw_msg_buf(struct ipu_isys_pipeline *ip)
 
 	isys = pipe_av->isys;
 
-	spin_lock_irqsave(&isys->listlock, flags);
-	if (list_empty(&isys->framebuflist)) {
-		spin_unlock_irqrestore(&isys->listlock, flags);
+	spin_lock_irqsave(&ip->listlock, flags);
+	if (list_empty(&ip->framebuflist)) {
+		spin_unlock_irqrestore(&ip->listlock, flags);
 		dev_dbg(&isys->adev->dev, "Frame list empty - Allocate more");
 
-		alloc_fw_msg_buffers(isys, 5);
+		alloc_fw_msg_bufs(ip, 5);
 
-		spin_lock_irqsave(&isys->listlock, flags);
-		if (list_empty(&isys->framebuflist)) {
+		spin_lock_irqsave(&ip->listlock, flags);
+		if (list_empty(&ip->framebuflist)) {
+			spin_unlock_irqrestore(&ip->listlock, flags);
 			dev_err(&isys->adev->dev, "Frame list empty");
-			spin_unlock_irqrestore(&isys->listlock, flags);
 			return NULL;
 		}
 	}
-	msg = list_last_entry(&isys->framebuflist, struct isys_fw_msgs, head);
-	list_move(&msg->head, &isys->framebuflist_fw);
-	spin_unlock_irqrestore(&isys->listlock, flags);
+	msg = list_last_entry(&ip->framebuflist, struct isys_fw_msgs, head);
+	list_move(&msg->head, &ip->framebuflist_fw);
+	spin_unlock_irqrestore(&ip->listlock, flags);
 	memset(&msg->fw_msg, 0, sizeof(msg->fw_msg));
 
 	return msg;
@@ -845,95 +759,97 @@ void ipu_cleanup_fw_msg_bufs(struct ipu_isys *isys)
 {
 	struct isys_fw_msgs *fwmsg, *fwmsg0;
 	unsigned long flags;
+	int i;
+
+	for (i = 0; i < IPU_ISYS_MAX_STREAMS; i++) {
+		struct ipu_isys_pipeline *pipe = isys->pipes[i];
 
-	spin_lock_irqsave(&isys->listlock, flags);
-	list_for_each_entry_safe(fwmsg, fwmsg0, &isys->framebuflist_fw, head)
-		list_move(&fwmsg->head, &isys->framebuflist);
-	spin_unlock_irqrestore(&isys->listlock, flags);
+		if (!pipe)
+			continue;
+
+		spin_lock_irqsave(&pipe->listlock, flags);
+		list_for_each_entry_safe(fwmsg, fwmsg0,
+					 &pipe->framebuflist_fw, head)
+			list_move(&fwmsg->head, &pipe->framebuflist);
+		spin_unlock_irqrestore(&pipe->listlock, flags);
+	}
 }
 
-void ipu_put_fw_mgs_buffer(struct ipu_isys *isys, u64 data)
+void ipu_put_fw_msg_buf(struct ipu_isys_pipeline *ip, u64 data)
 {
 	struct isys_fw_msgs *msg;
+	unsigned long flags;
 	u64 *ptr = (u64 *)(unsigned long)data;
 
 	if (!ptr)
 		return;
 
-	spin_lock(&isys->listlock);
+	spin_lock_irqsave(&ip->listlock, flags);
 	msg = container_of(ptr, struct isys_fw_msgs, fw_msg.dummy);
-	list_move(&msg->head, &isys->framebuflist);
-	spin_unlock(&isys->listlock);
+	list_move(&msg->head, &ip->framebuflist);
+	spin_unlock_irqrestore(&ip->listlock, flags);
 }
-EXPORT_SYMBOL_GPL(ipu_put_fw_mgs_buffer);
+EXPORT_SYMBOL_GPL(ipu_put_fw_msg_buf);
 
 static int isys_probe(struct ipu_bus_device *adev)
 {
 	struct ipu_isys *isys;
 	struct ipu_device *isp = adev->isp;
-#if defined(CONFIG_VIDEO_INTEL_IPU4) || defined(CONFIG_VIDEO_INTEL_IPU4P)
-	const u32 trace_size = IPU_ISYS_SHORT_PACKET_TRACE_BUFFER_SIZE;
-	dma_addr_t *trace_dma_addr;
-	unsigned long attrs;
-#endif
 	const struct firmware *fw;
 	int rval = 0;
 
-	trace_printk("B|%d|TMWK\n", current->pid);
-
-	/* Has the domain been attached? */
-	if (!isp->secure_mode && !isp->pkg_dir_dma_addr) {
-		trace_printk("E|TMWK\n");
-		return -EPROBE_DEFER;
-	}
-
 	isys = devm_kzalloc(&adev->dev, sizeof(*isys), GFP_KERNEL);
 	if (!isys)
 		return -ENOMEM;
 
+	rval = ipu_mmu_hw_init(adev->mmu);
+	if (rval)
+		return rval;
+
 	/* By default, short packet is captured from T-Unit. */
-#if defined(CONFIG_VIDEO_INTEL_IPU4) || defined(CONFIG_VIDEO_INTEL_IPU4P)
-	isys->short_packet_source = IPU_ISYS_SHORT_PACKET_FROM_TUNIT;
-	trace_dma_addr = &isys->short_packet_trace_buffer_dma_addr;
-	mutex_init(&isys->short_packet_tracing_mutex);
-	isys->short_packet_trace_buffer =
-	    dma_alloc_attrs(&adev->dev, trace_size, trace_dma_addr,
-			    GFP_KERNEL, attrs);
-	if (!isys->short_packet_trace_buffer)
-		return -ENOMEM;
-#else
 	isys->short_packet_source = IPU_ISYS_SHORT_PACKET_FROM_RECEIVER;
-#endif
 	isys->adev = adev;
 	isys->pdata = adev->pdata;
 
+	/* initial streamID for different sensor types */
+	isys->sensor_info.vc1_data_start =
+		IPU_FW_ISYS_VC1_SENSOR_DATA_START;
+	isys->sensor_info.vc1_data_end =
+		IPU_FW_ISYS_VC1_SENSOR_DATA_END;
+	isys->sensor_info.vc0_data_start =
+		IPU_FW_ISYS_VC0_SENSOR_DATA_START;
+	isys->sensor_info.vc0_data_end =
+		IPU_FW_ISYS_VC0_SENSOR_DATA_END;
+	isys->sensor_info.vc1_pdaf_start =
+		IPU_FW_ISYS_VC1_SENSOR_PDAF_START;
+	isys->sensor_info.vc1_pdaf_end =
+		IPU_FW_ISYS_VC1_SENSOR_PDAF_END;
+	isys->sensor_info.sensor_metadata =
+		IPU_FW_ISYS_SENSOR_METADATA;
+
+	isys->sensor_types[IPU_FW_ISYS_VC1_SENSOR_DATA] =
+		IPU_FW_ISYS_VC1_SENSOR_DATA_START;
+	isys->sensor_types[IPU_FW_ISYS_VC1_SENSOR_PDAF] =
+		IPU_FW_ISYS_VC1_SENSOR_PDAF_START;
+	isys->sensor_types[IPU_FW_ISYS_VC0_SENSOR_DATA] =
+		IPU_FW_ISYS_VC0_SENSOR_DATA_START;
+
 	INIT_LIST_HEAD(&isys->requests);
 
 	spin_lock_init(&isys->lock);
 	spin_lock_init(&isys->power_lock);
 	isys->power = 0;
+	isys->phy_termcal_val = 0;
 
 	mutex_init(&isys->mutex);
 	mutex_init(&isys->stream_mutex);
 	mutex_init(&isys->lib_mutex);
 
-	spin_lock_init(&isys->listlock);
-	INIT_LIST_HEAD(&isys->framebuflist);
-	INIT_LIST_HEAD(&isys->framebuflist_fw);
-
-	dev_info(&adev->dev, "isys probe %p %p\n", adev, &adev->dev);
+	dev_dbg(&adev->dev, "isys probe %p %p\n", adev, &adev->dev);
 	ipu_bus_set_drvdata(adev, isys);
 
 	isys->line_align = IPU_ISYS_2600_MEM_LINE_ALIGN;
-#ifdef CONFIG_VIDEO_INTEL_IPU4
-	isys->icache_prefetch = is_ipu_hw_bxtp_e0(isp);
-#else
 	isys->icache_prefetch = 0;
-#endif
-
-#ifndef CONFIG_PM
-	isys_setup_hw(isys);
-#endif
 
 	if (!isp->secure_mode) {
 		fw = isp->cpd_fw;
@@ -941,38 +857,43 @@ static int isys_probe(struct ipu_bus_device *adev)
 		if (rval)
 			goto release_firmware;
 
-		isys->pkg_dir = ipu_cpd_create_pkg_dir(adev, isp->cpd_fw->data,
-						       sg_dma_address(isys->
-								      fw_sgt.
-								      sgl),
-						       &isys->pkg_dir_dma_addr,
-						       &isys->pkg_dir_size);
+		isys->pkg_dir =
+		    ipu_cpd_create_pkg_dir(adev, isp->cpd_fw->data,
+					   sg_dma_address(isys->fw_sgt.sgl),
+					   &isys->pkg_dir_dma_addr,
+					   &isys->pkg_dir_size);
 		if (!isys->pkg_dir) {
 			rval = -ENOMEM;
 			goto remove_shared_buffer;
 		}
 	}
 
+#ifdef CONFIG_DEBUG_FS
 	/* Debug fs failure is not fatal. */
 	ipu_isys_init_debugfs(isys);
+#endif
 
 	ipu_trace_init(adev->isp, isys->pdata->base, &adev->dev,
 		       isys_trace_blocks);
 
 	cpu_latency_qos_add_request(&isys->pm_qos, PM_QOS_DEFAULT_VALUE);
-	alloc_fw_msg_buffers(isys, 20);
-
-	pm_runtime_allow(&adev->dev);
-	pm_runtime_enable(&adev->dev);
 
 	rval = isys_register_devices(isys);
 	if (rval)
 		goto out_remove_pkg_dir_shared_buffer;
+	rval = isys_iwake_watermark_init(isys);
+	if (rval)
+		goto out_unregister_devices;
+
+	ipu_mmu_hw_cleanup(adev->mmu);
 
-	trace_printk("E|TMWK\n");
 	return 0;
 
+out_unregister_devices:
+	isys_iwake_watermark_cleanup(isys);
+	isys_unregister_devices(isys);
 out_remove_pkg_dir_shared_buffer:
+	cpu_latency_qos_remove_request(&isys->pm_qos);
 	if (!isp->secure_mode)
 		ipu_cpd_free_pkg_dir(adev, isys->pkg_dir,
 				     isys->pkg_dir_dma_addr,
@@ -985,20 +906,13 @@ static int isys_probe(struct ipu_bus_device *adev)
 		release_firmware(isys->fw);
 	ipu_trace_uninit(&adev->dev);
 
-	trace_printk("E|TMWK\n");
-
 	mutex_destroy(&isys->mutex);
 	mutex_destroy(&isys->stream_mutex);
 
-	if (isys->short_packet_source == IPU_ISYS_SHORT_PACKET_FROM_TUNIT) {
+	if (isys->short_packet_source == IPU_ISYS_SHORT_PACKET_FROM_TUNIT)
 		mutex_destroy(&isys->short_packet_tracing_mutex);
-#if defined(CONFIG_VIDEO_INTEL_IPU4) || defined(CONFIG_VIDEO_INTEL_IPU4P)
-		dma_free_attrs(&adev->dev, trace_size,
-			       isys->short_packet_trace_buffer,
-			       isys->short_packet_trace_buffer_dma_addr,
-			       attrs);
-#endif
-	}
+
+	ipu_mmu_hw_cleanup(adev->mmu);
 
 	return rval;
 }
@@ -1056,7 +970,7 @@ int isys_isr_one(struct ipu_bus_device *adev)
 	if (!resp)
 		return 1;
 
-	ts = (u64) resp->timestamp[1] << 32 | resp->timestamp[0];
+	ts = (u64)resp->timestamp[1] << 32 | resp->timestamp[0];
 
 	if (resp->error_info.error == IPU_FW_ISYS_ERROR_STREAM_IN_SUSPENSION)
 		/* Suspension is kind of special case: not enough buffers */
@@ -1102,7 +1016,6 @@ int isys_isr_one(struct ipu_bus_device *adev)
 
 	switch (resp->type) {
 	case IPU_FW_ISYS_RESP_TYPE_STREAM_OPEN_DONE:
-		ipu_put_fw_mgs_buffer(ipu_bus_get_drvdata(adev), resp->buf_id);
 		complete(&pipe->stream_open_completion);
 		break;
 	case IPU_FW_ISYS_RESP_TYPE_STREAM_CLOSE_ACK:
@@ -1112,7 +1025,6 @@ int isys_isr_one(struct ipu_bus_device *adev)
 		complete(&pipe->stream_start_completion);
 		break;
 	case IPU_FW_ISYS_RESP_TYPE_STREAM_START_AND_CAPTURE_ACK:
-		ipu_put_fw_mgs_buffer(ipu_bus_get_drvdata(adev), resp->buf_id);
 		complete(&pipe->stream_start_completion);
 		break;
 	case IPU_FW_ISYS_RESP_TYPE_STREAM_STOP_ACK:
@@ -1122,6 +1034,11 @@ int isys_isr_one(struct ipu_bus_device *adev)
 		complete(&pipe->stream_stop_completion);
 		break;
 	case IPU_FW_ISYS_RESP_TYPE_PIN_DATA_READY:
+		/*
+		 * firmware only release the capture msg until software
+		 * get pin_data_ready event
+		 */
+		ipu_put_fw_msg_buf(pipe, resp->buf_id);
 		if (resp->pin_id < IPU_ISYS_OUTPUT_PINS &&
 		    pipe->output_pins[resp->pin_id].pin_ready)
 			pipe->output_pins[resp->pin_id].pin_ready(pipe, resp);
@@ -1129,10 +1046,11 @@ int isys_isr_one(struct ipu_bus_device *adev)
 			dev_err(&adev->dev,
 				"%d:No data pin ready handler for pin id %d\n",
 				resp->stream_handle, resp->pin_id);
+		if (pipe->csi2)
+			ipu_isys_csi2_error(pipe->csi2);
+
 		break;
 	case IPU_FW_ISYS_RESP_TYPE_STREAM_CAPTURE_ACK:
-		ipu_put_fw_mgs_buffer(ipu_bus_get_drvdata(adev), resp->buf_id);
-		complete(&pipe->capture_ack_completion);
 		break;
 	case IPU_FW_ISYS_RESP_TYPE_STREAM_START_AND_CAPTURE_DONE:
 	case IPU_FW_ISYS_RESP_TYPE_STREAM_CAPTURE_DONE:
@@ -1140,13 +1058,13 @@ int isys_isr_one(struct ipu_bus_device *adev)
 			struct ipu_isys_buffer *ib, *ib_safe;
 			struct list_head list;
 			unsigned long flags;
+			unsigned int *ts = resp->timestamp;
 
 			if (pipe->isys->short_packet_source ==
 			    IPU_ISYS_SHORT_PACKET_FROM_TUNIT)
 				pipe->cur_field =
-				    ipu_isys_csi2_get_current_field(pipe,
-								    resp->
-								    timestamp);
+				    ipu_isys_csi2_get_current_field(pipe, ts);
+
 			/*
 			 * Move the pending buffers to a local temp list.
 			 * Then we do not need to handle the lock during
@@ -1176,6 +1094,9 @@ int isys_isr_one(struct ipu_bus_device *adev)
 
 		break;
 	case IPU_FW_ISYS_RESP_TYPE_FRAME_SOF:
+		if (pipe->csi2)
+			ipu_isys_csi2_sof_event(pipe->csi2);
+
 		pipe->seq[pipe->seq_index].sequence =
 		    atomic_read(&pipe->sequence) - 1;
 		pipe->seq[pipe->seq_index].timestamp = ts;
@@ -1187,7 +1108,8 @@ int isys_isr_one(struct ipu_bus_device *adev)
 		    % IPU_ISYS_MAX_PARALLEL_SOF;
 		break;
 	case IPU_FW_ISYS_RESP_TYPE_FRAME_EOF:
-
+		if (pipe->csi2)
+			ipu_isys_csi2_eof_event(pipe->csi2);
 
 		dev_dbg(&adev->dev,
 			"eof: handle %d: (index %u), timestamp 0x%16.16llx\n",
diff --git a/drivers/media/pci/intel/ipu-isys.h b/drivers/media/pci/intel/ipu-isys.h
index 7980957c0e3c..4577baf6d69f 100644
--- a/drivers/media/pci/intel/ipu-isys.h
+++ b/drivers/media/pci/intel/ipu-isys.h
@@ -57,6 +57,12 @@
 #define IPU_ISYS_MAX_WIDTH		16384U
 #define IPU_ISYS_MAX_HEIGHT		16384U
 
+#ifdef CONFIG_IPU_SINGLE_BE_SOC_DEVICE
+#define NR_OF_CSI2_BE_SOC_DEV 1
+#else
+#define NR_OF_CSI2_BE_SOC_DEV 8
+#endif
+
 struct task_struct;
 
 struct ipu_isys_csi2_config {
@@ -69,6 +75,47 @@ struct sensor_async_sd {
 	struct ipu_isys_csi2_config csi2;
 };
 
+struct ltr_did {
+	union {
+		u32 value;
+		struct {
+			u8 val0;
+			u8 val1;
+			u8 val2;
+			u8 val3;
+		} bits;
+	} lut_ltr;
+	union {
+		u32 value;
+		struct {
+			u8 th0;
+			u8 th1;
+			u8 th2;
+			u8 th3;
+		} bits;
+	} lut_fill_time;
+};
+
+struct isys_iwake_watermark {
+	bool iwake_enabled;
+	bool force_iwake_disable;
+	u32 iwake_threshold;
+	u64 isys_pixelbuffer_datarate;
+	struct ltr_did ltrdid;
+	struct mutex mutex; /* protect whole struct */
+	struct ipu_isys *isys;
+	struct list_head video_list;
+};
+struct ipu_isys_sensor_info {
+	unsigned int vc1_data_start;
+	unsigned int vc1_data_end;
+	unsigned int vc0_data_start;
+	unsigned int vc0_data_end;
+	unsigned int vc1_pdaf_start;
+	unsigned int vc1_pdaf_end;
+	unsigned int sensor_metadata;
+};
+
 /*
  * struct ipu_isys
  *
@@ -84,6 +131,7 @@ struct sensor_async_sd {
  * @fwcom: fw communication layer private pointer
  *         or optional external library private pointer
  * @line_align: line alignment in memory
+ * @phy_termcal_val: the termination calibration value, only used for DWC PHY
  * @reset_needed: Isys requires d0i0->i3 transition
  * @video_opened: total number of opened file handles on video nodes
  * @mutex: serialise access isys video open/release related operations
@@ -114,16 +162,18 @@ struct ipu_isys {
 	struct ipu_isys_pipeline *pipes[IPU_ISYS_MAX_STREAMS];
 	void *fwcom;
 	unsigned int line_align;
+	u32 phy_termcal_val;
 	bool reset_needed;
 	bool icache_prefetch;
 	bool csi2_cse_ipc_not_supported;
 	unsigned int video_opened;
 	unsigned int stream_opened;
-#if !defined(CONFIG_VIDEO_INTEL_IPU4) && !defined(CONFIG_VIDEO_INTEL_IPU4P)
+	struct ipu_isys_sensor_info sensor_info;
 	unsigned int sensor_types[N_IPU_FW_ISYS_SENSOR_TYPE];
-#endif
 
+#ifdef CONFIG_DEBUG_FS
 	struct dentry *debugfsdir;
+#endif
 	struct mutex mutex;	/* Serialise isys video open/release related */
 	struct mutex stream_mutex;	/* Stream start, stop, queueing reqs */
 	struct mutex lib_mutex;	/* Serialise optional external library mutex */
@@ -134,8 +184,7 @@ struct ipu_isys {
 	struct ipu_isys_tpg *tpg;
 	struct ipu_isys_isa isa;
 	struct ipu_isys_csi2_be csi2_be;
-	struct ipu_isys_csi2_be_soc csi2_be_soc;
-
+	struct ipu_isys_csi2_be_soc csi2_be_soc[NR_OF_CSI2_BE_SOC_DEV];
 	const struct firmware *fw;
 	struct sg_table fw_sgt;
 
@@ -152,10 +201,9 @@ struct ipu_isys {
 	struct mutex short_packet_tracing_mutex;	/* For tracing count */
 	u64 tsc_timer_base;
 	u64 tunit_timer_base;
-	spinlock_t listlock;	/* Protect framebuflist */
-	struct list_head framebuflist;
-	struct list_head framebuflist_fw;
 	struct v4l2_async_notifier notifier;
+	struct isys_iwake_watermark *iwake_watermark;
+
 };
 
 struct isys_fw_msgs {
@@ -173,7 +221,7 @@ struct isys_fw_msgs {
 #define to_dma_addr(a) ((a)->dma_addr)
 
 struct isys_fw_msgs *ipu_get_fw_msg_buf(struct ipu_isys_pipeline *ip);
-void ipu_put_fw_mgs_buffer(struct ipu_isys *isys, u64 data);
+void ipu_put_fw_msg_buf(struct ipu_isys_pipeline *ip, u64 data);
 void ipu_cleanup_fw_msg_bufs(struct ipu_isys *isys);
 
 extern const struct v4l2_ioctl_ops ipu_isys_ioctl_ops;
diff --git a/drivers/media/pci/intel/ipu-mmu.c b/drivers/media/pci/intel/ipu-mmu.c
index 4fc81c03361f..4ffba52a47cd 100644
--- a/drivers/media/pci/intel/ipu-mmu.c
+++ b/drivers/media/pci/intel/ipu-mmu.c
@@ -71,108 +71,6 @@
 #define TBL_PHYS_ADDR(a)	((phys_addr_t)(a) << ISP_PADDR_SHIFT)
 #define TBL_VIRT_ADDR(a)	phys_to_virt(TBL_PHYS_ADDR(a))
 
-static void zlw_invalidate(struct ipu_mmu *mmu, struct ipu_mmu_hw *mmu_hw)
-{
-	unsigned int retry = 0;
-	unsigned int i, j;
-	int ret;
-
-	for (i = 0; i < mmu_hw->nr_l1streams; i++) {
-		/* We need to invalidate only the zlw enabled stream IDs */
-		if (mmu_hw->l1_zlw_en[i]) {
-			/*
-			 * Maximum 16 blocks per L1 stream
-			 * Write trash buffer iova offset to the FW_ZLW
-			 * register. This will trigger pre-fetching of next 16
-			 * pages from the page table. So we need to increment
-			 * iova address by 16 * 4K to trigger the next 16 pages.
-			 * Once this loop is completed, the L1 cache will be
-			 * filled with trash buffer translation.
-			 *
-			 * TODO: Instead of maximum 16 blocks, use the allocated
-			 * block size
-			 */
-			for (j = 0; j < mmu_hw->l1_block_sz[i]; j++)
-				writel(mmu->iova_addr_trash +
-					   j * MMUV2_TRASH_L1_BLOCK_OFFSET,
-					   mmu_hw->base +
-					   MMUV2_AT_REG_L1_ZLW_INSERTION(i));
-
-			/*
-			 * Now we need to fill the L2 cache entry. L2 cache
-			 * entries will be automatically updated, based on the
-			 * L1 entry. The above loop for L1 will update only one
-			 * of the two entries in L2 as the L1 is under 4MB
-			 * range. To force the other entry in L2 to update, we
-			 * just need to trigger another pre-fetch which is
-			 * outside the above 4MB range.
-			 */
-			writel(mmu->iova_addr_trash +
-				   MMUV2_TRASH_L2_BLOCK_OFFSET,
-				   mmu_hw->base +
-				   MMUV2_AT_REG_L1_ZLW_INSERTION(0));
-		}
-	}
-
-	/*
-	 * Wait until AT is ready. FIFO read should return 2 when AT is ready.
-	 * Retry value of 1000 is just by guess work to avoid the forever loop.
-	 */
-	do {
-		if (retry > 1000) {
-			dev_err(mmu->dev, "zlw invalidation failed\n");
-			return;
-		}
-		ret = readl(mmu_hw->base + MMUV2_AT_REG_L1_FW_ZLW_FIFO);
-		retry++;
-	} while (ret != 2);
-}
-
-static void tlb_invalidate(struct ipu_mmu *mmu)
-{
-	unsigned int i;
-	unsigned long flags;
-
-	spin_lock_irqsave(&mmu->ready_lock, flags);
-	if (!mmu->ready) {
-		spin_unlock_irqrestore(&mmu->ready_lock, flags);
-		return;
-	}
-
-	for (i = 0; i < mmu->nr_mmus; i++) {
-		u32 inv;
-
-		/*
-		 * To avoid the HW bug induced dead lock in some of the IPU4
-		 * MMUs on successive invalidate calls, we need to first do a
-		 * read to the page table base before writing the invalidate
-		 * register. MMUs which need to implement this WA, will have
-		 * the insert_read_before_invalidate flasg set as true.
-		 * Disregard the return value of the read.
-		 */
-		if (mmu->mmu_hw[i].insert_read_before_invalidate)
-			readl(mmu->mmu_hw[i].base + REG_L1_PHYS);
-
-		/* Normal invalidate or zlw invalidate */
-		if (mmu->mmu_hw[i].zlw_invalidate) {
-			/* trash buffer must be mapped by now, just in case! */
-			WARN_ON(!mmu->iova_addr_trash);
-
-			zlw_invalidate(mmu, &mmu->mmu_hw[i]);
-		} else {
-			if (mmu->mmu_hw[i].nr_l1streams == 32)
-				inv = 0xffffffff;
-			else if (mmu->mmu_hw[i].nr_l1streams == 0)
-				inv = MMU0_TLB_INVALIDATE;
-			else
-				inv = MMU1_TLB_INVALIDATE;
-			writel(inv, mmu->mmu_hw[i].base +
-				   REG_TLB_INVALIDATE);
-		}
-	}
-	spin_unlock_irqrestore(&mmu->ready_lock, flags);
-}
-
 #ifdef DEBUG
 static void page_table_dump(struct ipu_mmu_info *mmu_info)
 {
@@ -223,69 +121,122 @@ static u32 *alloc_page_table(struct ipu_mmu_info *mmu_info, bool l1)
 	return pt;
 }
 
+static dma_addr_t map_single(struct ipu_mmu_info *mmu_info, void *ptr)
+{
+	dma_addr_t dma;
+
+	dma = dma_map_single(mmu_info->dev, ptr, PAGE_SIZE, DMA_BIDIRECTIONAL);
+	if (dma_mapping_error(mmu_info->dev, dma))
+		return 0;
+
+	return dma;
+}
+
+static u32 *alloc_l2_pt(struct ipu_mmu_info *mmu_info)
+{
+	u32 *pt = (u32 *)get_zeroed_page(GFP_ATOMIC | GFP_DMA32);
+	int i;
+
+	if (!pt)
+		return NULL;
+
+	dev_dbg(mmu_info->dev, "%s get_zeroed_page() == %p\n", __func__, pt);
+
+	for (i = 0; i < ISP_L1PT_PTES; i++)
+		pt[i] = mmu_info->dummy_page_pteval;
+
+	return pt;
+}
+
+static void l2_unmap(struct ipu_mmu_info *mmu_info, unsigned long iova,
+		     phys_addr_t dummy, size_t size);
 static int l2_map(struct ipu_mmu_info *mmu_info, unsigned long iova,
 		  phys_addr_t paddr, size_t size)
 {
-	u32 l1_idx = iova >> ISP_L1PT_SHIFT;
-	u32 l1_entry = mmu_info->pgtbl[l1_idx];
-	u32 *l2_pt;
-	u32 iova_start = iova;
+	struct device *dev = mmu_info->dev;
+	u32 l1_idx;
+	u32 l1_entry;
+	u32 *l2_pt, *l2_virt;
 	unsigned int l2_idx;
 	unsigned long flags;
+	dma_addr_t dma;
+	unsigned int l2_entries;
+	size_t mapped = 0;
+	int err = 0;
 
-	pr_debug("mapping l2 page table for l1 index %u (iova %8.8x)\n",
-		 l1_idx, (u32) iova);
+	spin_lock_irqsave(&mmu_info->lock, flags);
 
-	if (l1_entry == mmu_info->dummy_l2_tbl) {
-		u32 *l2_virt = alloc_page_table(mmu_info, false);
+	paddr = ALIGN(paddr, ISP_PAGE_SIZE);
+	for (l1_idx = iova >> ISP_L1PT_SHIFT;
+	     size > 0 && l1_idx < ISP_L1PT_PTES; l1_idx++) {
+		dev_dbg(dev,
+			"mapping l2 page table for l1 index %u (iova %8.8x)\n",
+			l1_idx, (u32)iova);
+
+		l1_entry = mmu_info->l1_pt[l1_idx];
+		if (l1_entry == mmu_info->dummy_l2_pteval) {
+			l2_virt = mmu_info->l2_pts[l1_idx];
+			if (likely(!l2_virt)) {
+				l2_virt = alloc_l2_pt(mmu_info);
+				if (!l2_virt) {
+					err = -ENOMEM;
+					goto error;
+				}
+			}
 
-		if (!l2_virt)
-			return -ENOMEM;
+			dma = map_single(mmu_info, l2_virt);
+			if (!dma) {
+				dev_err(dev, "Failed to map l2pt page\n");
+				free_page((unsigned long)l2_virt);
+				err = -EINVAL;
+				goto error;
+			}
+
+			l1_entry = dma >> ISP_PADDR_SHIFT;
 
-		l1_entry = virt_to_phys(l2_virt) >> ISP_PADDR_SHIFT;
-		pr_debug("allocated page for l1_idx %u\n", l1_idx);
-
-		spin_lock_irqsave(&mmu_info->lock, flags);
-		if (mmu_info->pgtbl[l1_idx] == mmu_info->dummy_l2_tbl) {
-			mmu_info->pgtbl[l1_idx] = l1_entry;
-#ifdef CONFIG_X86
-			clflush_cache_range(&mmu_info->pgtbl[l1_idx],
-					    sizeof(mmu_info->pgtbl[l1_idx]));
-#endif /* CONFIG_X86 */
-		} else {
-			spin_unlock_irqrestore(&mmu_info->lock, flags);
-			free_page((unsigned long)TBL_VIRT_ADDR(l1_entry));
-			spin_lock_irqsave(&mmu_info->lock, flags);
+			dev_dbg(dev, "page for l1_idx %u %p allocated\n",
+				l1_idx, l2_virt);
+			mmu_info->l1_pt[l1_idx] = l1_entry;
+			mmu_info->l2_pts[l1_idx] = l2_virt;
+
+			clflush_cache_range(&mmu_info->l1_pt[l1_idx],
+					    sizeof(mmu_info->l1_pt[l1_idx]));
 		}
-	} else {
-		spin_lock_irqsave(&mmu_info->lock, flags);
-	}
 
-	l2_pt = TBL_VIRT_ADDR(mmu_info->pgtbl[l1_idx]);
+		l2_pt = mmu_info->l2_pts[l1_idx];
+		l2_entries = 0;
 
-	pr_debug("l2_pt at %p\n", l2_pt);
+		for (l2_idx = (iova & ISP_L2PT_MASK) >> ISP_L2PT_SHIFT;
+		     size > 0 && l2_idx < ISP_L2PT_PTES; l2_idx++) {
+			l2_pt[l2_idx] = paddr >> ISP_PADDR_SHIFT;
 
-	paddr = ALIGN(paddr, ISP_PAGE_SIZE);
+			dev_dbg(dev, "l2 index %u mapped as 0x%8.8x\n", l2_idx,
+				l2_pt[l2_idx]);
 
-	l2_idx = (iova_start & ISP_L2PT_MASK) >> ISP_L2PT_SHIFT;
+			iova += ISP_PAGE_SIZE;
+			paddr += ISP_PAGE_SIZE;
+			mapped += ISP_PAGE_SIZE;
+			size -= ISP_PAGE_SIZE;
 
-	pr_debug("l2_idx %u, phys 0x%8.8x\n", l2_idx, l2_pt[l2_idx]);
-	if (l2_pt[l2_idx] != mmu_info->dummy_page) {
-		spin_unlock_irqrestore(&mmu_info->lock, flags);
-		return -EBUSY;
-	}
+			l2_entries++;
+		}
 
-	l2_pt[l2_idx] = paddr >> ISP_PADDR_SHIFT;
+		WARN_ON_ONCE(!l2_entries);
+		clflush_cache_range(&l2_pt[l2_idx - l2_entries],
+				    sizeof(l2_pt[0]) * l2_entries);
+	}
 
 	spin_unlock_irqrestore(&mmu_info->lock, flags);
 
-#ifdef CONFIG_X86
-	clflush_cache_range(&l2_pt[l2_idx], sizeof(l2_pt[l2_idx]));
-#endif /* CONFIG_X86 */
+	return 0;
 
-	pr_debug("l2 index %u mapped as 0x%8.8x\n", l2_idx, l2_pt[l2_idx]);
+error:
+	spin_unlock_irqrestore(&mmu_info->lock, flags);
+	/* unroll mapping in case something went wrong */
+	if (mapped)
+		l2_unmap(mmu_info, iova - mapped, paddr - mapped, mapped);
 
-	return 0;
+	return err;
 }
 
 static int __ipu_mmu_map(struct ipu_mmu_info *mmu_info, unsigned long iova,
@@ -301,65 +252,89 @@ static int __ipu_mmu_map(struct ipu_mmu_info *mmu_info, unsigned long iova,
 	return l2_map(mmu_info, iova_start, paddr, size);
 }
 
-static size_t l2_unmap(struct ipu_mmu_info *mmu_info, unsigned long iova,
-		       phys_addr_t dummy, size_t size)
+static void l2_unmap(struct ipu_mmu_info *mmu_info, unsigned long iova,
+		     phys_addr_t dummy, size_t size)
 {
-	u32 l1_idx = iova >> ISP_L1PT_SHIFT;
-	u32 *l2_pt = TBL_VIRT_ADDR(mmu_info->pgtbl[l1_idx]);
-	u32 iova_start = iova;
+	u32 l1_idx;
+	u32 *l2_pt;
 	unsigned int l2_idx;
+	unsigned int l2_entries;
 	size_t unmapped = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&mmu_info->lock, flags);
+	for (l1_idx = iova >> ISP_L1PT_SHIFT;
+	     size > 0 && l1_idx < ISP_L1PT_PTES; l1_idx++) {
+		dev_dbg(mmu_info->dev,
+			"unmapping l2 page table for l1 index %u (iova 0x%8.8lx)\n",
+			l1_idx, iova);
+
+		if (mmu_info->l1_pt[l1_idx] == mmu_info->dummy_l2_pteval) {
+			dev_err(mmu_info->dev,
+				"unmap iova 0x%8.8lx l1 idx %u which was not mapped\n",
+				iova, l1_idx);
+			continue;
+		}
+		l2_pt = mmu_info->l2_pts[l1_idx];
 
-	pr_debug("unmapping l2 page table for l1 index %u (iova 0x%8.8lx)\n",
-		 l1_idx, iova);
+		l2_entries = 0;
+		for (l2_idx = (iova & ISP_L2PT_MASK) >> ISP_L2PT_SHIFT;
+		     size > 0 && l2_idx < ISP_L2PT_PTES; l2_idx++) {
+			dev_dbg(mmu_info->dev,
+				"unmap l2 index %u with pteval 0x%10.10llx\n",
+				l2_idx, TBL_PHYS_ADDR(l2_pt[l2_idx]));
+			l2_pt[l2_idx] = mmu_info->dummy_page_pteval;
 
-	if (mmu_info->pgtbl[l1_idx] == mmu_info->dummy_l2_tbl)
-		return -EINVAL;
+			iova += ISP_PAGE_SIZE;
+			unmapped += ISP_PAGE_SIZE;
+			size -= ISP_PAGE_SIZE;
+
+			l2_entries++;
+		}
 
-	pr_debug("l2_pt at %p\n", l2_pt);
-
-	for (l2_idx = (iova_start & ISP_L2PT_MASK) >> ISP_L2PT_SHIFT;
-	     (iova_start & ISP_L1PT_MASK) + (l2_idx << ISP_PAGE_SHIFT)
-	     < iova_start + size && l2_idx < ISP_L2PT_PTES; l2_idx++) {
-		unsigned long flags;
-
-		pr_debug("l2 index %u unmapped, was 0x%10.10llx\n",
-			 l2_idx, TBL_PHYS_ADDR(l2_pt[l2_idx]));
-		spin_lock_irqsave(&mmu_info->lock, flags);
-		l2_pt[l2_idx] = mmu_info->dummy_page;
-		spin_unlock_irqrestore(&mmu_info->lock, flags);
-#ifdef CONFIG_X86
-		clflush_cache_range(&l2_pt[l2_idx], sizeof(l2_pt[l2_idx]));
-#endif /* CONFIG_X86 */
-		unmapped++;
+		WARN_ON_ONCE(!l2_entries);
+		clflush_cache_range(&l2_pt[l2_idx - l2_entries],
+				    sizeof(l2_pt[0]) * l2_entries);
 	}
 
-	return unmapped << ISP_PAGE_SHIFT;
+	WARN_ON_ONCE(size);
+	spin_unlock_irqrestore(&mmu_info->lock, flags);
 }
 
 static size_t __ipu_mmu_unmap(struct ipu_mmu_info *mmu_info,
 			    unsigned long iova, size_t size)
 {
-	return l2_unmap(mmu_info, iova, 0, size);
+	l2_unmap(mmu_info, iova, 0, size);
+	return 0;
 }
 
-static int allocate_trash_buffer(struct ipu_bus_device *adev)
+static int allocate_trash_buffer(struct ipu_mmu *mmu)
 {
-	struct ipu_mmu *mmu = ipu_bus_get_drvdata(adev);
 	unsigned int n_pages = PAGE_ALIGN(IPU_MMUV2_TRASH_RANGE) >> PAGE_SHIFT;
 	struct iova *iova;
 	u32 iova_addr;
 	unsigned int i;
+	dma_addr_t dma;
 	int ret;
 
 	/* Allocate 8MB in iova range */
 	iova = alloc_iova(&mmu->dmap->iovad, n_pages,
-			  dma_get_mask(mmu->dev) >> PAGE_SHIFT, 0);
+			  mmu->dmap->mmu_info->aperture_end >> PAGE_SHIFT, 0);
 	if (!iova) {
-		dev_err(&adev->dev, "cannot allocate iova range for trash\n");
+		dev_err(mmu->dev, "cannot allocate iova range for trash\n");
 		return -ENOMEM;
 	}
 
+	dma = dma_map_page(mmu->dmap->mmu_info->dev, mmu->trash_page, 0,
+			   PAGE_SIZE, DMA_BIDIRECTIONAL);
+	if (dma_mapping_error(mmu->dmap->mmu_info->dev, dma)) {
+		dev_err(mmu->dmap->mmu_info->dev, "Failed to map trash page\n");
+		ret = -ENOMEM;
+		goto out_free_iova;
+	}
+
+	mmu->pci_trash_page = dma;
+
 	/*
 	 * Map the 8MB iova address range to the same physical trash page
 	 * mmu->trash_page which is already reserved at the probe
@@ -367,9 +342,9 @@ static int allocate_trash_buffer(struct ipu_bus_device *adev)
 	iova_addr = iova->pfn_lo;
 	for (i = 0; i < n_pages; i++) {
 		ret = ipu_mmu_map(mmu->dmap->mmu_info, iova_addr << PAGE_SHIFT,
-				page_to_phys(mmu->trash_page), PAGE_SIZE);
+				  mmu->pci_trash_page, PAGE_SIZE);
 		if (ret) {
-			dev_err(&adev->dev,
+			dev_err(mmu->dev,
 				"mapping trash buffer range failed\n");
 			goto out_unmap;
 		}
@@ -377,111 +352,63 @@ static int allocate_trash_buffer(struct ipu_bus_device *adev)
 		iova_addr++;
 	}
 
-	/* save the address for the ZLW invalidation */
-	mmu->iova_addr_trash = iova->pfn_lo << PAGE_SHIFT;
-	dev_info(&adev->dev, "iova trash buffer for MMUID: %d is %u\n",
-		 mmu->mmid, (unsigned int)mmu->iova_addr_trash);
+	mmu->iova_trash_page = iova->pfn_lo << PAGE_SHIFT;
+	dev_dbg(mmu->dev, "iova trash buffer for MMUID: %d is %u\n",
+		mmu->mmid, (unsigned int)mmu->iova_trash_page);
 	return 0;
 
 out_unmap:
 	ipu_mmu_unmap(mmu->dmap->mmu_info, iova->pfn_lo << PAGE_SHIFT,
-		    (iova->pfn_hi - iova->pfn_lo + 1) << PAGE_SHIFT);
+		      (iova->pfn_hi - iova->pfn_lo + 1) << PAGE_SHIFT);
+	dma_unmap_page(mmu->dmap->mmu_info->dev, mmu->pci_trash_page,
+		       PAGE_SIZE, DMA_BIDIRECTIONAL);
+out_free_iova:
 	__free_iova(&mmu->dmap->iovad, iova);
 	return ret;
 }
 
-static int ipu_mmu_hw_init(struct device *dev)
+int ipu_mmu_hw_init(struct ipu_mmu *mmu)
 {
-	struct ipu_bus_device *adev = to_ipu_bus_device(dev);
-	struct ipu_mmu *mmu = ipu_bus_get_drvdata(adev);
 	unsigned int i;
 	unsigned long flags;
 	struct ipu_mmu_info *mmu_info;
 
-	dev_dbg(dev, "mmu hw init\n");
-	/*
-	 * FIXME: following fix for null pointer check is not a complete one.
-	 * if mmu is not powered cycled before being used, the page table
-	 * address will still not be set into HW.
-	 */
-	if (!mmu->dmap) {
-		dev_warn(dev, "mmu is not ready yet. skipping.\n");
-		return 0;
-	}
+	dev_dbg(mmu->dev, "mmu hw init\n");
 
 	mmu_info = mmu->dmap->mmu_info;
 
 	/* Initialise the each MMU HW block */
 	for (i = 0; i < mmu->nr_mmus; i++) {
 		struct ipu_mmu_hw *mmu_hw = &mmu->mmu_hw[i];
-#if defined(CONFIG_VIDEO_INTEL_IPU4) || defined(CONFIG_VIDEO_INTEL_IPU4P)
-		bool zlw_invalidate = false;
-#endif
 		unsigned int j;
 		u16 block_addr;
 
 		/* Write page table address per MMU */
-		writel((phys_addr_t) virt_to_phys(mmu_info->pgtbl)
-			   >> ISP_PADDR_SHIFT,
-			   mmu->mmu_hw[i].base + REG_L1_PHYS);
+		writel((phys_addr_t)mmu_info->l1_pt_dma,
+		       mmu->mmu_hw[i].base + REG_L1_PHYS);
 
 		/* Set info bits per MMU */
 		writel(mmu->mmu_hw[i].info_bits,
-			   mmu->mmu_hw[i].base + REG_INFO);
+		       mmu->mmu_hw[i].base + REG_INFO);
 
 		/* Configure MMU TLB stream configuration for L1 */
 		for (j = 0, block_addr = 0; j < mmu_hw->nr_l1streams;
 		     block_addr += mmu->mmu_hw[i].l1_block_sz[j], j++) {
 			if (block_addr > IPU_MAX_LI_BLOCK_ADDR) {
-				dev_err(dev, "invalid L1 configuration\n");
+				dev_err(mmu->dev, "invalid L1 configuration\n");
 				return -EINVAL;
 			}
 
 			/* Write block start address for each streams */
 			writel(block_addr, mmu_hw->base +
 				   mmu_hw->l1_stream_id_reg_offset + 4 * j);
-
-#if defined(CONFIG_VIDEO_INTEL_IPU4) || defined(CONFIG_VIDEO_INTEL_IPU4P)
-			/* Enable ZLW for streams based on the init table */
-			writel(mmu->mmu_hw[i].l1_zlw_en[j],
-				   mmu_hw->base +
-				   MMUV2_AT_REG_L1_ZLW_EN_SID(j));
-
-			/* To track if zlw is enabled in any streams */
-			zlw_invalidate |= mmu->mmu_hw[i].l1_zlw_en[j];
-
-			/* Enable ZLW 1D mode for streams from the init table */
-			writel(mmu->mmu_hw[i].l1_zlw_1d_mode[j],
-				   mmu_hw->base +
-				   MMUV2_AT_REG_L1_ZLW_1DMODE_SID(j));
-
-			/* Set when the ZLW insertion will happen */
-			writel(mmu->mmu_hw[i].l1_ins_zlw_ahead_pages[j],
-				   mmu_hw->base +
-				   MMUV2_AT_REG_L1_ZLW_INS_N_AHEAD_SID(j));
-
-			/* Set if ZLW 2D mode active for each streams */
-			writel(mmu->mmu_hw[i].l1_zlw_2d_mode[j],
-				   mmu_hw->base +
-				   MMUV2_AT_REG_L1_ZLW_2DMODE_SID(j));
-#endif
 		}
 
-#if defined(CONFIG_VIDEO_INTEL_IPU4) || defined(CONFIG_VIDEO_INTEL_IPU4P)
-		/*
-		 * If ZLW invalidate is enabled even for one stream in a MMU1,
-		 * we need to set the FW ZLW operations have higher priority
-		 * on that MMU1
-		 */
-		if (zlw_invalidate)
-			writel(1, mmu_hw->base +
-				   MMUV2_AT_REG_L1_FW_ZLW_PRIO);
-#endif
 		/* Configure MMU TLB stream configuration for L2 */
 		for (j = 0, block_addr = 0; j < mmu_hw->nr_l2streams;
 		     block_addr += mmu->mmu_hw[i].l2_block_sz[j], j++) {
 			if (block_addr > IPU_MAX_L2_BLOCK_ADDR) {
-				dev_err(dev, "invalid L2 configuration\n");
+				dev_err(mmu->dev, "invalid L2 configuration\n");
 				return -EINVAL;
 			}
 
@@ -490,21 +417,22 @@ static int ipu_mmu_hw_init(struct device *dev)
 		}
 	}
 
-	/* Allocate trash buffer, if not allocated. Only once per MMU */
-	if (!mmu->iova_addr_trash) {
+	if (!mmu->trash_page) {
 		int ret;
 
-		ret = allocate_trash_buffer(adev);
+		mmu->trash_page = alloc_page(GFP_KERNEL);
+		if (!mmu->trash_page) {
+			dev_err(mmu->dev, "insufficient memory for trash buffer\n");
+			return -ENOMEM;
+		}
+
+		ret = allocate_trash_buffer(mmu);
 		if (ret) {
-			dev_err(dev, "trash buffer allocation failed\n");
+			__free_page(mmu->trash_page);
+			mmu->trash_page = NULL;
+			dev_err(mmu->dev, "trash buffer allocation failed\n");
 			return ret;
 		}
-
-		/*
-		 * Update the domain pointer to trash buffer to release it on
-		 * domain destroy
-		 */
-		mmu_info->iova_addr_trash = mmu->iova_addr_trash;
 	}
 
 	spin_lock_irqsave(&mmu->ready_lock, flags);
@@ -513,18 +441,19 @@ static int ipu_mmu_hw_init(struct device *dev)
 
 	return 0;
 }
+EXPORT_SYMBOL(ipu_mmu_hw_init);
 
-static void set_mapping(struct ipu_mmu *mmu, struct ipu_dma_mapping *dmap)
+int ipu_mmu_hw_cleanup(struct ipu_mmu *mmu)
 {
-	mmu->dmap = dmap;
+	unsigned long flags;
 
-	if (!dmap)
-		return;
+	spin_lock_irqsave(&mmu->ready_lock, flags);
+	mmu->ready = false;
+	spin_unlock_irqrestore(&mmu->ready_lock, flags);
 
-	pm_runtime_get_sync(mmu->dev);
-	ipu_mmu_hw_init(mmu->dev);
-	pm_runtime_put(mmu->dev);
+	return 0;
 }
+EXPORT_SYMBOL(ipu_mmu_hw_cleanup);
 
 phys_addr_t ipu_mmu_iova_to_phys(struct ipu_mmu_info *mmu_info,
 					dma_addr_t iova)
@@ -751,116 +680,6 @@ void ipu_mmu_destroy(struct ipu_mmu_info *mmu_info)
 }
 EXPORT_SYMBOL(ipu_mmu_destroy);
 
-static int ipu_mmu_probe(struct ipu_bus_device *adev)
-{
-	struct ipu_mmu_pdata *pdata;
-	struct ipu_mmu *mmu;
-
-	mmu = devm_kzalloc(&adev->dev, sizeof(*mmu), GFP_KERNEL);
-	if (!mmu)
-		return -ENOMEM;
-
-	dev_dbg(&adev->dev, "mmu probe %p %p\n", adev, &adev->dev);
-	ipu_bus_set_drvdata(adev, mmu);
-
-	pdata = adev->pdata;
-
-	mmu->mmid = pdata->mmid;
-
-	mmu->mmu_hw = pdata->mmu_hw;
-	mmu->nr_mmus = pdata->nr_mmus;
-	mmu->tlb_invalidate = tlb_invalidate;
-	mmu->set_mapping = set_mapping;
-	mmu->dev = &adev->dev;
-	mmu->ready = false;
-	spin_lock_init(&mmu->ready_lock);
-
-	/*
-	 * Allocate 1 page of physical memory for the trash buffer
-	 *
-	 * TODO! Could be further optimized by allocating only one page per ipu
-	 * instance instead of per mmu
-	 */
-	mmu->trash_page = alloc_page(GFP_KERNEL);
-	if (!mmu->trash_page) {
-		dev_err(&adev->dev, "insufficient memory for trash buffer\n");
-		return -ENOMEM;
-	}
-	dev_info(&adev->dev, "MMU: %d, allocated page for trash: 0x%p\n",
-		 mmu->mmid, mmu->trash_page);
-
-	pm_runtime_allow(&adev->dev);
-	pm_runtime_enable(&adev->dev);
-
-	/*
-	 * FIXME: We can't unload this --- bus_set_iommu() will
-	 * register a notifier which must stay until the devices are
-	 * gone.
-	 */
-	__module_get(THIS_MODULE);
-
-	return 0;
-}
-
-/*
- * Leave iommu ops as they were --- this means we must be called as
- * the very last.
- */
-static void ipu_mmu_remove(struct ipu_bus_device *adev)
-{
-	struct ipu_mmu *mmu = ipu_bus_get_drvdata(adev);
-
-	__free_page(mmu->trash_page);
-	dev_dbg(&adev->dev, "removed\n");
-}
-
-static irqreturn_t ipu_mmu_isr(struct ipu_bus_device *adev)
-{
-	dev_info(&adev->dev, "Yeah!\n");
-	return IRQ_NONE;
-}
-
-#ifdef CONFIG_PM
-static int ipu_mmu_suspend(struct device *dev)
-{
-	struct ipu_bus_device *adev = to_ipu_bus_device(dev);
-	struct ipu_mmu *mmu = ipu_bus_get_drvdata(adev);
-	unsigned long flags;
-
-	spin_lock_irqsave(&mmu->ready_lock, flags);
-	mmu->ready = false;
-	spin_unlock_irqrestore(&mmu->ready_lock, flags);
-
-	return 0;
-}
-
-static const struct dev_pm_ops ipu_mmu_pm_ops = {
-	.resume = ipu_mmu_hw_init,
-	.suspend = ipu_mmu_suspend,
-	.runtime_resume = ipu_mmu_hw_init,
-	.runtime_suspend = ipu_mmu_suspend,
-};
-
-#define IPU_MMU_PM_OPS	(&ipu_mmu_pm_ops)
-
-#else /* !CONFIG_PM */
-
-#define IPU_MMU_PM_OPS	NULL
-
-#endif /* !CONFIG_PM */
-
-struct ipu_bus_driver ipu_mmu_driver = {
-	.probe = ipu_mmu_probe,
-	.remove = ipu_mmu_remove,
-	.isr = ipu_mmu_isr,
-	.wanted = IPU_MMU_NAME,
-	.drv = {
-		.name = IPU_MMU_NAME,
-		.owner = THIS_MODULE,
-		.pm = IPU_MMU_PM_OPS,
-	},
-};
-
 MODULE_AUTHOR("Sakari Ailus <sakari.ailus@linux.intel.com>");
 MODULE_AUTHOR("Samu Onkalo <samu.onkalo@intel.com>");
 MODULE_LICENSE("GPL");
diff --git a/drivers/media/pci/intel/ipu-mmu.h b/drivers/media/pci/intel/ipu-mmu.h
index f81a1e4c91e7..40a5c20bc681 100644
--- a/drivers/media/pci/intel/ipu-mmu.h
+++ b/drivers/media/pci/intel/ipu-mmu.h
@@ -18,6 +18,17 @@ extern struct ipu_bus_driver ipu_mmu_driver;
  */
 struct ipu_mmu_info {
 	u32 __iomem *pgtbl;
+	struct device *dev;
+
+	u32 __iomem *l1_pt;
+	u32 l1_pt_dma;
+	u32 **l2_pts;
+
+	u32 *dummy_l2_pt;
+	u32 dummy_l2_pteval;
+	void *dummy_page;
+	u32 dummy_page_pteval;
+
 	dma_addr_t aperture_start;
 	dma_addr_t aperture_end;
 	unsigned long pgsize_bitmap;
@@ -26,8 +37,6 @@ struct ipu_mmu_info {
 	unsigned int users;
 	struct ipu_dma_mapping *dmap;
 	u32 dummy_l2_tbl;
-	u32 dummy_page;
-
 	/* Reference to the trash address to unmap on domain destroy */
 	dma_addr_t iova_addr_trash;
 };
@@ -47,9 +56,11 @@ struct ipu_mmu {
 	struct device *dev;
 
 	struct ipu_dma_mapping *dmap;
+	struct list_head vma_list;
 
 	struct page *trash_page;
-	dma_addr_t iova_addr_trash;
+	dma_addr_t pci_trash_page; /* IOVA from PCI DMA services (parent) */
+	dma_addr_t iova_trash_page; /* IOVA for IPU child nodes to use */
 
 	bool ready;
 	spinlock_t ready_lock;	/* Serialize access to bool ready */
@@ -61,6 +72,8 @@ struct ipu_mmu {
 
 struct ipu_mmu_info *ipu_mmu_alloc(void);
 void ipu_mmu_destroy(struct ipu_mmu_info *mmu_info);
+int ipu_mmu_hw_init(struct ipu_mmu *mmu);
+int ipu_mmu_hw_cleanup(struct ipu_mmu *mmu);
 int ipu_mmu_map(struct ipu_mmu_info *mmu_info, unsigned long iova,
 	      phys_addr_t paddr, size_t size);
 size_t ipu_mmu_unmap(struct ipu_mmu_info *mmu_info, unsigned long iova,
diff --git a/drivers/media/pci/intel/ipu.c b/drivers/media/pci/intel/ipu.c
index 0272a37f7f08..f94ea65cdf5e 100644
--- a/drivers/media/pci/intel/ipu.c
+++ b/drivers/media/pci/intel/ipu.c
@@ -729,7 +729,6 @@ static int __init ipu_init(void)
 
 static void __exit ipu_exit(void)
 {
-	ipu_bus_unregister_driver(&ipu_mmu_driver);
 	pci_unregister_driver(&ipu_pci_driver);
 	ipu_bus_unregister();
 }
diff --git a/drivers/media/pci/intel/ipu4/ipu-platform-isys-csi2-reg.h b/drivers/media/pci/intel/ipu4/ipu-platform-isys-csi2-reg.h
index efdf287e38f6..e74f6563b5d9 100644
--- a/drivers/media/pci/intel/ipu4/ipu-platform-isys-csi2-reg.h
+++ b/drivers/media/pci/intel/ipu4/ipu-platform-isys-csi2-reg.h
@@ -56,17 +56,17 @@
 #define CSI2_REG_CSI2S2M_IRQ_ENABLE		        0xD10
 #define CSI2_REG_CSI2S2M_IRQ_LEVEL_NOT_PULSE	        0xD14
 
-#ifdef IPU_VC_SUPPORT
-#define CSI2_IRQ_FS_VC(chn)	(0x10000 << ((chn) * 4))
-#define CSI2_IRQ_FE_VC(chn)	(0x20000 << ((chn) * 4))
-#define CSI2_IRQ_LS_VC(chn)	(0x40000 << ((chn) * 4))
-#define CSI2_IRQ_LE_VC(chn)	(0x80000 << ((chn) * 4))
-#else
+// #ifdef IPU_VC_SUPPORT
+// #define CSI2_IRQ_FS_VC(chn)	(0x10000 << ((chn) * 4))
+// #define CSI2_IRQ_FE_VC(chn)	(0x20000 << ((chn) * 4))
+// #define CSI2_IRQ_LS_VC(chn)	(0x40000 << ((chn) * 4))
+// #define CSI2_IRQ_LE_VC(chn)	(0x80000 << ((chn) * 4))
+// #else
 #define CSI2_IRQ_FS_VC		0x10000
 #define CSI2_IRQ_FE_VC		0x20000
 #define CSI2_IRQ_LS_VC		0x40000
 #define CSI2_IRQ_LE_VC		0x80000
-#endif /* IPU_VC_SUPPORT */
+// #endif /* IPU_VC_SUPPORT */
 #define CSI2_REG_CL0_IBUFCTL_EN_FLUSH_FOR_IDRAIN	0x6002c
 #define CSI2_REG_CL1_IBUFCTL_EN_FLUSH_FOR_IDRAIN	0x6802c
 #define IPU_REG_ISYS_IBUFCTL_EN_FLUSH_FOR_IDRAIN	0xb602c
@@ -115,17 +115,17 @@
 #define CSI2_REG_CSI2S2M_IRQ_ENABLE			0x610
 #define CSI2_REG_CSI2S2M_IRQ_LEVEL_NOT_PULSE		0x614
 
-#ifdef IPU_VC_SUPPORT
-#define CSI2_IRQ_FS_VC(chn)				(1 << ((chn) * 4))
-#define CSI2_IRQ_FE_VC(chn)				(2 << ((chn) * 4))
-#define CSI2_IRQ_LS_VC(chn)				(4 << ((chn) * 4))
-#define CSI2_IRQ_LE_VC(chn)				(8 << ((chn) * 4))
-#else
+// #ifdef IPU_VC_SUPPORT
+// #define CSI2_IRQ_FS_VC(chn)				(1 << ((chn) * 4))
+// #define CSI2_IRQ_FE_VC(chn)				(2 << ((chn) * 4))
+// #define CSI2_IRQ_LS_VC(chn)				(4 << ((chn) * 4))
+// #define CSI2_IRQ_LE_VC(chn)				(8 << ((chn) * 4))
+// #else
 #define CSI2_IRQ_FS_VC					1
 #define CSI2_IRQ_FE_VC					2
 #define CSI2_IRQ_LS_VC					4
 #define CSI2_IRQ_LE_VC					8
-#endif /* IPU_VC_SUPPORT */
+// #endif /* IPU_VC_SUPPORT */
 #endif /* CONFIG_VIDEO_INTEL_IPU4 */
 
 #define CSI2_REG_CSI_RX_ENABLE				0x00
diff --git a/drivers/media/pci/intel/ipu4/ipu4-isys-isa.c b/drivers/media/pci/intel/ipu4/ipu4-isys-isa.c
index 4ac6545ecc73..c772bfc1f816 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-isys-isa.c
+++ b/drivers/media/pci/intel/ipu4/ipu4-isys-isa.c
@@ -244,12 +244,7 @@ static void isa_set_ffmt(struct v4l2_subdev *sd,
 			 struct v4l2_subdev_format *fmt)
 {
 	struct v4l2_mbus_framefmt *ffmt =
-#ifdef IPU_VC_SUPPORT
-		__ipu_isys_get_ffmt(sd, cfg, fmt->pad, fmt->stream,
-					   fmt->which);
-#else
 		__ipu_isys_get_ffmt(sd, cfg, fmt->pad, fmt->which);
-#endif
 	enum ipu_isys_subdev_pixelorder order;
 	enum isys_subdev_prop_tgt tgt;
 
@@ -263,12 +258,7 @@ static void isa_set_ffmt(struct v4l2_subdev *sd,
 		return;
 	case ISA_PAD_SOURCE: {
 		struct v4l2_mbus_framefmt *sink_ffmt =
-#ifdef IPU_VC_SUPPORT
-			__ipu_isys_get_ffmt(sd, cfg, ISA_PAD_SINK,
-						   fmt->stream, fmt->which);
-#else
 			__ipu_isys_get_ffmt(sd, cfg, ISA_PAD_SINK, fmt->which);
-#endif
 		struct v4l2_rect *r =
 			__ipu_isys_get_selection(sd, cfg,
 							V4L2_SEL_TGT_CROP,
@@ -291,12 +281,8 @@ static void isa_set_ffmt(struct v4l2_subdev *sd,
 		return;
 	case ISA_PAD_SOURCE_SCALED: {
 		struct v4l2_mbus_framefmt *sink_ffmt =
-#ifdef IPU_VC_SUPPORT
 			__ipu_isys_get_ffmt(sd, cfg, ISA_PAD_SINK,
-						   fmt->stream, fmt->which);
-#else
-			__ipu_isys_get_ffmt(sd, cfg, ISA_PAD_SINK, fmt->which);
-#endif
+						   fmt->which);
 		struct v4l2_rect *r =
 			__ipu_isys_get_selection(sd, cfg,
 							V4L2_SEL_TGT_CROP,
diff --git a/drivers/media/pci/intel/ipu4/ipu4-isys.c b/drivers/media/pci/intel/ipu4/ipu4-isys.c
index d23669a3103d..69e0d6e3d61b 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-isys.c
+++ b/drivers/media/pci/intel/ipu4/ipu4-isys.c
@@ -336,11 +336,7 @@ irqreturn_t isys_isr(struct ipu_bus_device *adev)
 int tpg_set_stream(struct v4l2_subdev *sd, int enable)
 {
 	struct ipu_isys_tpg *tpg = to_ipu_isys_tpg(sd);
-#ifdef IPU_VC_SUPPORT
-	__u32 code = tpg->asd.ffmt[TPG_PAD_SOURCE][0].code;
-#else
 	__u32 code = tpg->asd.ffmt[TPG_PAD_SOURCE].code;
-#endif
 	unsigned int bpp = ipu_isys_mbus_code_to_bpp(code);
 
 	/*
@@ -363,16 +359,6 @@ int tpg_set_stream(struct v4l2_subdev *sd, int enable)
 
 	writel(0, tpg->base + MIPI_GEN_REG_SYNG_NOF_FRAMES);
 
-#ifdef IPU_VC_SUPPORT
-	writel(DIV_ROUND_UP(tpg->asd.ffmt[TPG_PAD_SOURCE][0].width *
-				bpp, BITS_PER_BYTE),
-		   tpg->base + MIPI_GEN_REG_COM_WCOUNT);
-	writel(DIV_ROUND_UP(tpg->asd.ffmt[TPG_PAD_SOURCE][0].width,
-				MIPI_GEN_PPC),
-		   tpg->base + MIPI_GEN_REG_SYNG_NOF_PIXELS);
-	writel(tpg->asd.ffmt[TPG_PAD_SOURCE][0].height,
-		   tpg->base + MIPI_GEN_REG_SYNG_NOF_LINES);
-#else
 	writel(DIV_ROUND_UP(tpg->asd.ffmt[TPG_PAD_SOURCE].width *
 				bpp, BITS_PER_BYTE),
 		   tpg->base + MIPI_GEN_REG_COM_WCOUNT);
@@ -381,7 +367,6 @@ int tpg_set_stream(struct v4l2_subdev *sd, int enable)
 		   tpg->base + MIPI_GEN_REG_SYNG_NOF_PIXELS);
 	writel(tpg->asd.ffmt[TPG_PAD_SOURCE].height,
 		   tpg->base + MIPI_GEN_REG_SYNG_NOF_LINES);
-#endif
 
 	writel(0, tpg->base + MIPI_GEN_REG_TPG_MODE);
 	writel(-1, tpg->base + MIPI_GEN_REG_TPG_HCNT_MASK);
diff --git a/drivers/media/pci/intel/ipu4/ipu4p-isys-csi2.c b/drivers/media/pci/intel/ipu4/ipu4p-isys-csi2.c
index 580a90835bbb..7d855a419c4c 100644
--- a/drivers/media/pci/intel/ipu4/ipu4p-isys-csi2.c
+++ b/drivers/media/pci/intel/ipu4/ipu4p-isys-csi2.c
@@ -13,6 +13,8 @@
 #define CSI2_UPDATE_TIME_TRY_NUM   3
 #define CSI2_UPDATE_TIME_MAX_DIFF  20
 
+#define IPU_ISYS_SHORT_PACKET_DTYPE_MASK	0x3f
+
 static int ipu4p_csi2_ev_correction_params(struct ipu_isys_csi2
 					   *csi2, unsigned int lanes)
 {
@@ -191,7 +193,7 @@ void ipu_isys_csi2_isr(struct ipu_isys_csi2 *csi2)
 {
 	u32 status = 0;
 #ifdef IPU_VC_SUPPORT
-	unsigned int i, bus;
+	unsigned int bus;
 #else
 	unsigned int bus;
 #endif
@@ -217,20 +219,10 @@ void ipu_isys_csi2_isr(struct ipu_isys_csi2 *csi2)
 	/* register the csi sync error */
 	csi2->receiver_errors |= status & 0xffff;
 	/* handle sof and eof event */
-#ifdef IPU_VC_SUPPORT
-	for (i = 0; i < NR_OF_CSI2_VC; i++) {
-		if (status & CSI2_IRQ_FS_VC(i))
-			ipu_isys_csi2_sof_event(csi2, i);
-
-		if (status & CSI2_IRQ_FE_VC(i))
-			ipu_isys_csi2_eof_event(csi2, i);
-	}
-#else
 	if (status & CSI2_IRQ_FS_VC)
 		ipu_isys_csi2_sof_event(csi2);
 	if (status & CSI2_IRQ_FE_VC)
 		ipu_isys_csi2_eof_event(csi2);
-#endif
 }
 
 static u64 tunit_time_to_us(struct ipu_isys *isys, u64 time)
@@ -325,90 +317,26 @@ unsigned int ipu_isys_csi2_get_current_field(struct ipu_isys_pipeline *ip,
 	struct ipu_isys *isys = av->isys;
 	unsigned int field = V4L2_FIELD_TOP;
 
-	/*
-	 * Find the nearest message that has matched msg type,
-	 * port id, virtual channel and packet type.
-	 */
-	unsigned int i = ip->short_packet_trace_index;
-	bool msg_matched = false;
-	unsigned int monitor_id;
-
-	update_timer_base(isys);
-
-	if (ip->csi2->index >= IPU_ISYS_MAX_CSI2_LEGACY_PORTS)
-		monitor_id = TRACE_REG_CSI2_3PH_TM_MONITOR_ID;
-	else
-		monitor_id = TRACE_REG_CSI2_TM_MONITOR_ID;
-
-	dma_sync_single_for_cpu(&isys->adev->dev,
-				isys->short_packet_trace_buffer_dma_addr,
-				IPU_ISYS_SHORT_PACKET_TRACE_BUFFER_SIZE,
-				DMA_BIDIRECTIONAL);
-
-	do {
-		struct ipu_isys_csi2_monitor_message msg =
-		    isys->short_packet_trace_buffer[i];
-		u64 sof_time = tsc_time_to_tunit_time(isys,
-						      isys->tsc_timer_base,
-						      isys->tunit_timer_base,
-						      (((u64) timestamp[1]) <<
-						       32) | timestamp[0]);
-		u64 trace_time = extract_time_from_short_packet_msg(&msg);
-		u64 delta_time_us = tunit_time_to_us(isys,
-						     (sof_time > trace_time) ?
-						     sof_time - trace_time :
-						     trace_time - sof_time);
-
-		i = (i + 1) % IPU_ISYS_SHORT_PACKET_TRACE_MSG_NUMBER;
-
-		if (msg.cmd == TRACE_REG_CMD_TYPE_D64MTS &&
-		    msg.monitor_id == monitor_id &&
-		    msg.fs == 1 &&
-		    msg.port == ip->csi2->index &&
-#ifdef IPU_VC_SUPPORT
-		    msg.vc == ip->vc &&
-#endif
-		    delta_time_us < IPU_ISYS_SHORT_PACKET_TRACE_MAX_TIMESHIFT) {
-			field = (msg.sequence % 2) ?
-			    V4L2_FIELD_TOP : V4L2_FIELD_BOTTOM;
-			ip->short_packet_trace_index = i;
-			msg_matched = true;
-			dev_dbg(&isys->adev->dev,
-				"Interlaced field ready. field = %d\n", field);
-			break;
-		}
-	} while (i != ip->short_packet_trace_index);
-	if (!msg_matched)
-		/* We have walked through the whole buffer. */
-		dev_dbg(&isys->adev->dev, "No matched trace message found.\n");
+	struct ipu_isys_buffer *short_packet_ib =
+		list_last_entry(&ip->short_packet_active,
+				struct ipu_isys_buffer, head);
+	struct ipu_isys_private_buffer *pb =
+		ipu_isys_buffer_to_private_buffer(short_packet_ib);
+	struct ipu_isys_mipi_packet_header *ph =
+		(struct ipu_isys_mipi_packet_header *)
+		pb->buffer;
+
+	/* Check if the first SOF packet is received. */
+	if ((ph->dtype & IPU_ISYS_SHORT_PACKET_DTYPE_MASK) != 0)
+		dev_warn(&isys->adev->dev, "First short packet is not SOF.\n");
+	field = (ph->word_count % 2) ? V4L2_FIELD_TOP : V4L2_FIELD_BOTTOM;
+	dev_dbg(&isys->adev->dev,
+		"Interlaced field ready. frame_num = %d field = %d\n",
+		ph->word_count, field);
 
 	return field;
 }
 
-bool ipu_isys_csi2_skew_cal_required(struct ipu_isys_csi2 *csi2)
-{
-	__s64 link_freq;
-	int rval;
-
-	if (!csi2)
-		return false;
-
-#ifdef IPU_VC_SUPPORT
-	/* Not yet ? */
-	if (csi2->remote_streams != csi2->stream_count)
-		return false;
-
-#endif
-	rval = ipu_isys_csi2_get_link_freq(csi2, &link_freq);
-	if (rval)
-		return false;
-
-	if (link_freq <= IPU_SKEW_CAL_LIMIT_HZ)
-		return false;
-
-	return true;
-}
-
 int ipu_isys_csi2_set_skew_cal(struct ipu_isys_csi2 *csi2, int enable)
 {
 	u32 val;
-- 
2.51.0

