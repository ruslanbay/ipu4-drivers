From 975e6e85cf0102525d519cd2325315ba1e118097 Mon Sep 17 00:00:00 2001
From: ruslanbay <67730802+ruslanbay@users.noreply.github.com>
Date: Sun, 21 Dec 2025 15:01:11 +0100
Subject: [PATCH 14/54] media: intel/ipu4: Integrate IPU ISYS with ipu-bridge
 for sensor discovery

Add integration with the ipu-bridge module to enable automatic sensor
discovery and attachment. This includes implementing async notifier callbacks
for bound sensors and VCM instantiation support.
---
 drivers/media/pci/intel/ipu-isys.c | 119 +++++++++++++++++++++++++++++
 drivers/media/pci/intel/ipu-isys.h |  11 +++
 drivers/media/pci/intel/ipu.c      |  13 ++++
 include/media/ipu-isys.h           |   5 --
 4 files changed, 143 insertions(+), 5 deletions(-)

diff --git a/drivers/media/pci/intel/ipu-isys.c b/drivers/media/pci/intel/ipu-isys.c
index 95344bb1ac87..40ae88e6be79 100644
--- a/drivers/media/pci/intel/ipu-isys.c
+++ b/drivers/media/pci/intel/ipu-isys.c
@@ -13,6 +13,7 @@
 #include <linux/sched.h>
 #include <linux/version.h>
 
+#include <media/ipu-bridge.h>
 #include <media/ipu-isys.h>
 #include <media/v4l2-mc.h>
 #include <media/v4l2-subdev.h>
@@ -394,6 +395,118 @@ static struct media_device_ops isys_mdev_ops = {
 	.req_queue = ipu_isys_req_queue,
 };
 
+/* The .bound() notifier callback when a match is found */
+static int isys_notifier_bound(struct v4l2_async_notifier *notifier,
+			       struct v4l2_subdev *sd,
+			       struct v4l2_async_subdev *asd)
+{
+	struct ipu_isys *isys =
+		container_of(notifier, struct ipu_isys, notifier);
+	struct sensor_async_sd *s_asd =
+		container_of(asd, struct sensor_async_sd, asd);
+	int ret;
+
+	if (s_asd->csi2.port >= isys->pdata->ipdata->csi2.nports) {
+		dev_err(&isys->adev->dev, "invalid csi2 port %u\n",
+			s_asd->csi2.port);
+		return -EINVAL;
+	}
+
+	ret = ipu_bridge_instantiate_vcm(sd->dev);
+	if (ret) {
+		dev_err(&isys->adev->dev, "instantiate vcm failed\n");
+		return ret;
+	}
+
+	dev_dbg(&isys->adev->dev, "bind %s nlanes is %d port is %d\n",
+		sd->name, s_asd->csi2.nlanes, s_asd->csi2.port);
+	ret = isys_complete_ext_device_registration(isys, sd, &s_asd->csi2);
+	if (ret)
+		return ret;
+
+	return v4l2_device_register_subdev_nodes(&isys->v4l2_dev);
+}
+
+static int isys_notifier_complete(struct v4l2_async_notifier *notifier)
+{
+	struct ipu_isys *isys =
+		container_of(notifier, struct ipu_isys, notifier);
+
+	return v4l2_device_register_subdev_nodes(&isys->v4l2_dev);
+}
+
+static const struct v4l2_async_notifier_operations isys_async_ops = {
+	.bound = isys_notifier_bound,
+	.complete = isys_notifier_complete,
+};
+
+#define ISYS_MAX_PORTS 8
+static int isys_notifier_init(struct ipu_isys *isys)
+{
+	struct ipu_device *isp = isys->adev->isp;
+	struct device *dev = &isp->pdev->dev;
+	unsigned int i;
+	int ret;
+
+	v4l2_async_nf_init(&isys->notifier);
+
+	for (i = 0; i < ISYS_MAX_PORTS; i++) {
+		struct v4l2_fwnode_endpoint vep = {
+			.bus_type = V4L2_MBUS_CSI2_DPHY
+		};
+		struct sensor_async_sd *s_asd;
+		struct fwnode_handle *ep;
+
+		ep = fwnode_graph_get_endpoint_by_id(dev_fwnode(dev), i, 0,
+						FWNODE_GRAPH_ENDPOINT_NEXT);
+		if (!ep)
+			continue;
+
+		ret = v4l2_fwnode_endpoint_parse(ep, &vep);
+		if (ret) {
+			dev_err(dev, "fwnode endpoint parse failed: %d\n", ret);
+			goto err_parse;
+		}
+
+		s_asd = v4l2_async_nf_add_fwnode_remote(&isys->notifier, ep,
+							struct sensor_async_sd);
+		if (IS_ERR(s_asd)) {
+			ret = PTR_ERR(s_asd);
+			dev_err(dev, "add remove fwnode failed: %d\n", ret);
+			goto err_parse;
+		}
+
+		s_asd->csi2.port = vep.base.port;
+		s_asd->csi2.nlanes = vep.bus.mipi_csi2.num_data_lanes;
+
+		dev_dbg(dev, "remote endpoint port %d with %d lanes added\n",
+			s_asd->csi2.port, s_asd->csi2.nlanes);
+
+		fwnode_handle_put(ep);
+
+		continue;
+
+err_parse:
+		fwnode_handle_put(ep);
+		return ret;
+	}
+
+	isys->notifier.ops = &isys_async_ops;
+	ret = v4l2_async_nf_register(&isys->v4l2_dev, &isys->notifier);
+	if (ret) {
+		dev_err(dev, "failed to register async notifier : %d\n", ret);
+		v4l2_async_nf_cleanup(&isys->notifier);
+	}
+
+	return ret;
+}
+
+static void isys_notifier_cleanup(struct ipu_isys *isys)
+{
+	v4l2_async_nf_unregister(&isys->notifier);
+	v4l2_async_nf_cleanup(&isys->notifier);
+}
+
 static int isys_register_devices(struct ipu_isys *isys)
 {
 	int rval;
@@ -433,6 +546,10 @@ static int isys_register_devices(struct ipu_isys *isys)
 	if (rval)
 		goto out_isys_unregister_subdevices;
 
+	rval = isys_notifier_init(isys);
+	if (rval)
+		goto out_isys_unregister_subdevices;
+
 	return 0;
 
 out_isys_unregister_subdevices:
@@ -572,6 +689,7 @@ static void isys_remove(struct ipu_bus_device *adev)
 
 	ipu_trace_uninit(&adev->dev);
 	isys_unregister_devices(isys);
+	isys_notifier_cleanup(isys);
 	cpu_latency_qos_remove_request(&isys->pm_qos);
 
 	if (!isp->secure_mode) {
@@ -1144,3 +1262,4 @@ MODULE_AUTHOR("Yu Xia <yu.y.xia@intel.com>");
 MODULE_AUTHOR("Jerry Hu <jerry.w.hu@intel.com>");
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Intel ipu input system driver");
+MODULE_IMPORT_NS(INTEL_IPU_BRIDGE);
diff --git a/drivers/media/pci/intel/ipu-isys.h b/drivers/media/pci/intel/ipu-isys.h
index a16f9e164161..606c0ebfc96a 100644
--- a/drivers/media/pci/intel/ipu-isys.h
+++ b/drivers/media/pci/intel/ipu-isys.h
@@ -59,6 +59,16 @@
 
 struct task_struct;
 
+struct ipu_isys_csi2_config {
+	unsigned int nlanes;
+	unsigned int port;
+};
+
+struct sensor_async_sd {
+	struct v4l2_async_subdev asd;
+	struct ipu_isys_csi2_config csi2;
+};
+
 /*
  * struct ipu_isys
  *
@@ -145,6 +155,7 @@ struct ipu_isys {
 	spinlock_t listlock;	/* Protect framebuflist */
 	struct list_head framebuflist;
 	struct list_head framebuflist_fw;
+	struct v4l2_async_notifier notifier;
 };
 
 struct isys_fw_msgs {
diff --git a/drivers/media/pci/intel/ipu.c b/drivers/media/pci/intel/ipu.c
index b74e21523488..0272a37f7f08 100644
--- a/drivers/media/pci/intel/ipu.c
+++ b/drivers/media/pci/intel/ipu.c
@@ -12,6 +12,9 @@
 #include <linux/pm_runtime.h>
 #include <linux/timer.h>
 #include <linux/sched.h>
+#include <linux/vmalloc.h>
+
+#include <media/ipu-bridge.h>
 
 #include "ipu.h"
 #include "ipu-buttress.h"
@@ -34,6 +37,15 @@ static struct ipu_bus_device *ipu_mmu_init(struct pci_dev *pdev,
 					   const struct ipu_hw_variants *hw,
 					   unsigned int nr, int mmid)
 {
+	struct device *dev = &pdev->dev;
+
+	int ret;
+	ret = ipu_bridge_init(dev, ipu_bridge_parse_ssdb);
+	if (ret) {
+		dev_err_probe(dev, ret, "IPU6 bridge init failed\n");
+		return ERR_PTR(ret);
+	}
+
 	struct ipu_mmu_pdata *pdata =
 	    devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
 	unsigned int i;
@@ -725,6 +737,7 @@ static void __exit ipu_exit(void)
 module_init(ipu_init);
 module_exit(ipu_exit);
 
+MODULE_IMPORT_NS(INTEL_IPU_BRIDGE);
 MODULE_AUTHOR("Sakari Ailus <sakari.ailus@linux.intel.com>");
 MODULE_AUTHOR("Jouni HÃ¶gander <jouni.hogander@intel.com>");
 MODULE_AUTHOR("Antti Laakso <antti.laakso@intel.com>");
diff --git a/include/media/ipu-isys.h b/include/media/ipu-isys.h
index b2acb94a1fb1..13a6960c6a9b 100644
--- a/include/media/ipu-isys.h
+++ b/include/media/ipu-isys.h
@@ -9,11 +9,6 @@
 
 #define IPU_ISYS_MAX_CSI2_LANES		4
 
-struct ipu_isys_csi2_config {
-	unsigned int nlanes;
-	unsigned int port;
-};
-
 struct ipu_isys_subdev_i2c_info {
 	struct i2c_board_info board_info;
 	int i2c_adapter_id;
-- 
2.51.0

