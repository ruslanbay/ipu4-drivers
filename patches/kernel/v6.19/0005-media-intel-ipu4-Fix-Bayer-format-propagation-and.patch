From b9fe2b17df6996a4626851defa278cad755bc726 Mon Sep 17 00:00:00 2001
From: Ruslan Bay <ruslanbey@proton.me>
Date: Thu, 26 Feb 2026 17:21:03 +0100
Subject: [PATCH 05/54] media: intel/ipu4: Fix Bayer format propagation and

simplify state handling

Refactor the ISYS subdevice infrastructure to modernize state management and
fix pixel order issues during cropping. The current implementation of format
propagation relies on complex, manual pad interdependence checks
(has_pad_interdep) and legacy routing logic. This patch replaces these custom
checks with a streamlined propagation model that updates all source pads
based on the sink configuration, aligning with modern V4L2 subdevice state
handling.

Key Changes:
 - Bayer Order Correction: Introduces a raw Bayer format lookup table and
 index-based calculation in the CSI-2 BE-SOC driver. This ensures that the
 MEDIA_BUS_FMT is correctly updated (e.g., swapping BGGR to GBRG) when
 an odd-numbered vertical crop is applied, preventing color corruption
 downstream.
 - Infrastructure Simplification: Removes has_pad_interdep and
 ipu_isys_subdev_has_route logic. The propagation logic now uniformly updates
 source pads, significantly reducing code complexity in ipu-isys-subdev.c.
 - V4L2 State Migration: Renames and updates v4l2_subdev_pad_config references
 to the modern v4l2_subdev_state API.
 - Cleanup: Removes deprecated #if blocks for IPU4/IPU4P and eliminates
 redundant conditional checks for n:n and 1:n pad mapping scenarios.

This modernization improves maintainability and ensures hardware cropping behaves predictably across different Bayer patterns.
---
 .../media/pci/intel/ipu-isys-csi2-be-soc.c    |  96 ++++++++------
 drivers/media/pci/intel/ipu-isys-csi2.c       |   9 --
 drivers/media/pci/intel/ipu-isys-subdev.c     | 125 +++++++-----------
 3 files changed, 101 insertions(+), 129 deletions(-)

diff --git a/drivers/media/pci/intel/ipu-isys-csi2-be-soc.c b/drivers/media/pci/intel/ipu-isys-csi2-be-soc.c
index c2cfc2b7e005..6fbb698b0c17 100644
--- a/drivers/media/pci/intel/ipu-isys-csi2-be-soc.c
+++ b/drivers/media/pci/intel/ipu-isys-csi2-be-soc.c
@@ -46,6 +46,38 @@ static const u32 csi2_be_soc_supported_codes_pad[] = {
 	0,
 };
 
+/*
+ * Raw bayer format pixel order MUST BE MAINTAINED in groups of four codes.
+ * Otherwise pixel order calculation below WILL BREAK!
+ */
+static const u32 csi2_be_soc_supported_raw_bayer_codes_pad[] = {
+	MEDIA_BUS_FMT_SBGGR12_1X12,
+	MEDIA_BUS_FMT_SGBRG12_1X12,
+	MEDIA_BUS_FMT_SGRBG12_1X12,
+	MEDIA_BUS_FMT_SRGGB12_1X12,
+	MEDIA_BUS_FMT_SBGGR10_1X10,
+	MEDIA_BUS_FMT_SGBRG10_1X10,
+	MEDIA_BUS_FMT_SGRBG10_1X10,
+	MEDIA_BUS_FMT_SRGGB10_1X10,
+	MEDIA_BUS_FMT_SBGGR8_1X8,
+	MEDIA_BUS_FMT_SGBRG8_1X8,
+	MEDIA_BUS_FMT_SGRBG8_1X8,
+	MEDIA_BUS_FMT_SRGGB8_1X8,
+	MEDIA_BUS_FMT_Y8_1X8,
+	0,
+};
+
+static int get_supported_code_index(u32 code)
+{
+	int i;
+
+	for (i = 0; csi2_be_soc_supported_raw_bayer_codes_pad[i]; i++) {
+		if (csi2_be_soc_supported_raw_bayer_codes_pad[i] == code)
+			return i;
+	}
+	return -EINVAL;
+}
+
 static const u32 *csi2_be_soc_supported_codes[NR_OF_CSI2_BE_SOC_PADS];
 
 static struct v4l2_subdev_internal_ops csi2_be_soc_sd_internal_ops = {
@@ -148,73 +180,55 @@ static struct v4l2_subdev_ops csi2_be_soc_sd_ops = {
 
 static struct media_entity_operations csi2_be_soc_entity_ops = {
 	.link_validate = v4l2_subdev_link_validate,
-	.has_route = ipu_isys_subdev_has_route,
 };
 
 static void csi2_be_soc_set_ffmt(struct v4l2_subdev *sd,
-		 struct v4l2_subdev_state *cfg,
+				 struct v4l2_subdev_state *state,
 				 struct v4l2_subdev_format *fmt)
 {
 	struct v4l2_mbus_framefmt *ffmt =
-		__ipu_isys_get_ffmt(sd, cfg, fmt->pad,
+		__ipu_isys_get_ffmt(sd, state, fmt->pad,
 				    fmt->stream,
 				    fmt->which);
 
-#if !defined(CONFIG_VIDEO_INTEL_IPU4) && !defined(CONFIG_VIDEO_INTEL_IPU4P)
-			struct ipu_isys_csi2_be_soc *csi2_be_soc =
-						to_ipu_isys_csi2_be_soc(sd);
-#endif
-
 	if (sd->entity.pads[fmt->pad].flags & MEDIA_PAD_FL_SINK) {
 		if (fmt->format.field != V4L2_FIELD_ALTERNATE)
 			fmt->format.field = V4L2_FIELD_NONE;
 		*ffmt = fmt->format;
 
-		ipu_isys_subdev_fmt_propagate(sd, cfg, &fmt->format,
+		ipu_isys_subdev_fmt_propagate(sd, state, &fmt->format,
 					      NULL,
 					      IPU_ISYS_SUBDEV_PROP_TGT_SINK_FMT,
 					      fmt->pad, fmt->which);
 	} else if (sd->entity.pads[fmt->pad].flags & MEDIA_PAD_FL_SOURCE) {
 		struct v4l2_mbus_framefmt *sink_ffmt;
-		struct v4l2_rect *r;
+		struct v4l2_rect *r = __ipu_isys_get_selection(sd, state,
+			V4L2_SEL_TGT_CROP, fmt->pad, fmt->which);
 		struct ipu_isys_subdev *asd = to_ipu_isys_subdev(sd);
-		unsigned int sink_pad = 0;
-		int i;
+		u32 code;
+		int idx;
 
-		for (i = 0; i < asd->nsinks; i++)
-			if (media_entity_has_route(&sd->entity, fmt->pad, i))
-				break;
-		if (i != asd->nsinks)
-			sink_pad = i;
-		sink_ffmt = __ipu_isys_get_ffmt(sd, cfg, sink_pad,
-						fmt->stream,
-						fmt->which);
-		r = __ipu_isys_get_selection(sd, cfg, V4L2_SEL_TGT_CROP,
-					     fmt->pad, fmt->which);
+		sink_ffmt = __ipu_isys_get_ffmt(sd, state, 0, 0, fmt->which);
+		code = sink_ffmt->code;
+		idx = get_supported_code_index(code);
+
+		if (asd->valid_tgts[fmt->pad].crop && idx >= 0) {
+			int crop_info = 0;
+
+			/* Only croping odd line at top side. */
+			if (r->top & 1)
+				crop_info |= CSI2_BE_CROP_VER;
+
+			code = csi2_be_soc_supported_raw_bayer_codes_pad
+				[((idx & CSI2_BE_CROP_MASK) ^ crop_info)
+				+ (idx & ~CSI2_BE_CROP_MASK)];
 
+		}
+		ffmt->code = code;
 		ffmt->width = r->width;
 		ffmt->height = r->height;
-		ffmt->code = sink_ffmt->code;
 		ffmt->field = sink_ffmt->field;
 
-#if !defined(CONFIG_VIDEO_INTEL_IPU4) && !defined(CONFIG_VIDEO_INTEL_IPU4P)
-		/*
-		 * For new IPU special case, format changing in BE-SOC,
-		 * from YUV422 to I420, which is used to adapt multiple
-		 * YUV sensors and provide I420 to BB for partial processing.
-		 * Use original source pad format from user space.
-		 * And change pin type to RAW_DUAL_SOC for this special case
-		 */
-		if (fmt->format.code == MEDIA_BUS_FMT_UYVY8_2X8 &&
-			(sink_ffmt->code == MEDIA_BUS_FMT_YUYV8_1X16 ||
-			sink_ffmt->code == MEDIA_BUS_FMT_UYVY8_1X16)) {
-			ffmt->code = fmt->format.code;
-
-			for (i = 0; i < NR_OF_CSI2_BE_SOC_SOURCE_PADS; i++)
-				csi2_be_soc->av[i].aq.css_pin_type =
-					IPU_FW_ISYS_PIN_TYPE_RAW_DUAL_SOC;
-		}
-#endif
 	}
 }
 
diff --git a/drivers/media/pci/intel/ipu-isys-csi2.c b/drivers/media/pci/intel/ipu-isys-csi2.c
index a154ecead133..dd84d58ee753 100644
--- a/drivers/media/pci/intel/ipu-isys-csi2.c
+++ b/drivers/media/pci/intel/ipu-isys-csi2.c
@@ -438,14 +438,6 @@ static int csi2_link_validate(struct media_link *link)
 	return 0;
 }
 
-static bool csi2_has_route(struct media_entity *entity, unsigned int pad0,
-			   unsigned int pad1, int *stream)
-{
-	if (pad0 == CSI2_PAD_META || pad1 == CSI2_PAD_META)
-		return true;
-	return ipu_isys_subdev_has_route(entity, pad0, pad1, stream);
-}
-
 static const struct v4l2_subdev_video_ops csi2_sd_video_ops = {
 	.s_stream = set_stream,
 };
@@ -527,7 +519,6 @@ static struct v4l2_subdev_ops csi2_sd_ops = {
 
 static struct media_entity_operations csi2_entity_ops = {
 	.link_validate = csi2_link_validate,
-	.has_route = csi2_has_route,
 };
 
 static void csi2_set_ffmt(struct v4l2_subdev *sd,
diff --git a/drivers/media/pci/intel/ipu-isys-subdev.c b/drivers/media/pci/intel/ipu-isys-subdev.c
index 6a514a7fc75e..8d015862c2a3 100644
--- a/drivers/media/pci/intel/ipu-isys-subdev.c
+++ b/drivers/media/pci/intel/ipu-isys-subdev.c
@@ -209,11 +209,11 @@ static int target_valid(struct v4l2_subdev *sd, unsigned int target,
 }
 
 int ipu_isys_subdev_fmt_propagate(struct v4l2_subdev *sd,
-		    struct v4l2_subdev_state *cfg,
-				   struct v4l2_mbus_framefmt *ffmt,
-				   struct v4l2_rect *r,
-				   enum isys_subdev_prop_tgt tgt,
-				   unsigned int pad, unsigned int which)
+				  struct v4l2_subdev_state *state,
+				  struct v4l2_mbus_framefmt *ffmt,
+				  struct v4l2_rect *r,
+				  enum isys_subdev_prop_tgt tgt,
+				  unsigned int pad, unsigned int which)
 {
 	struct ipu_isys_subdev *asd = to_ipu_isys_subdev(sd);
 	struct v4l2_mbus_framefmt **ffmts = NULL;
@@ -241,18 +241,19 @@ int ipu_isys_subdev_fmt_propagate(struct v4l2_subdev *sd,
 		goto out_subdev_fmt_propagate;
 	}
 	compose = kcalloc(sd->entity.num_pads,
-			sizeof(*compose), GFP_KERNEL);
+			  sizeof(*compose), GFP_KERNEL);
 	if (!compose) {
 		rval = -ENOMEM;
 		goto out_subdev_fmt_propagate;
 	}
 
 	for (i = 0; i < sd->entity.num_pads; i++) {
-		ffmts[i] = __ipu_isys_get_ffmt(sd, cfg, i, 0, which);
-		crops[i] = __ipu_isys_get_selection(
-			sd, cfg, V4L2_SEL_TGT_CROP, i, which);
-		compose[i] = __ipu_isys_get_selection(
-			sd, cfg, V4L2_SEL_TGT_COMPOSE, i, which);
+		ffmts[i] = __ipu_isys_get_ffmt(sd, state, i, 0, which);
+		crops[i] = __ipu_isys_get_selection(sd, state, V4L2_SEL_TGT_CROP,
+						    i, which);
+		compose[i] = __ipu_isys_get_selection(sd, state,
+						      V4L2_SEL_TGT_COMPOSE,
+						      i, which);
 	}
 
 	switch (tgt) {
@@ -261,8 +262,8 @@ int ipu_isys_subdev_fmt_propagate(struct v4l2_subdev *sd,
 		crops[pad]->top = 0;
 		crops[pad]->width = ffmt->width;
 		crops[pad]->height = ffmt->height;
-		rval = ipu_isys_subdev_fmt_propagate(sd, cfg, ffmt, crops[pad],
-					      tgt + 1, pad, which);
+		rval = ipu_isys_subdev_fmt_propagate(sd, state, ffmt, crops[pad],
+						     tgt + 1, pad, which);
 		goto out_subdev_fmt_propagate;
 	case IPU_ISYS_SUBDEV_PROP_TGT_SINK_CROP:
 		if (WARN_ON(sd->entity.pads[pad].flags & MEDIA_PAD_FL_SOURCE))
@@ -272,9 +273,9 @@ int ipu_isys_subdev_fmt_propagate(struct v4l2_subdev *sd,
 		compose[pad]->top = 0;
 		compose[pad]->width = r->width;
 		compose[pad]->height = r->height;
-		rval = ipu_isys_subdev_fmt_propagate(sd, cfg, ffmt,
-					      compose[pad], tgt + 1,
-					      pad, which);
+		rval = ipu_isys_subdev_fmt_propagate(sd, state, ffmt,
+						     compose[pad], tgt + 1,
+						     pad, which);
 		goto out_subdev_fmt_propagate;
 	case IPU_ISYS_SUBDEV_PROP_TGT_SINK_COMPOSE:
 		if (WARN_ON(sd->entity.pads[pad].flags & MEDIA_PAD_FL_SOURCE)) {
@@ -282,56 +283,22 @@ int ipu_isys_subdev_fmt_propagate(struct v4l2_subdev *sd,
 			goto out_subdev_fmt_propagate;
 		}
 
-		/* 1:n and 1:1 case: only propagate to the first source pad */
-		if (asd->nsinks == 1 && asd->nsources >= 1) {
-			compose[asd->nsinks]->left =
-			    compose[asd->nsinks]->top = 0;
-			compose[asd->nsinks]->width = r->width;
-			compose[asd->nsinks]->height = r->height;
-			rval = ipu_isys_subdev_fmt_propagate(sd, cfg, ffmt,
-						      compose[asd->nsinks],
-						      tgt + 1, asd->nsinks,
-						      which);
+		for (i = 1; i < sd->entity.num_pads; i++) {
+			if (!(sd->entity.pads[i].flags &
+					MEDIA_PAD_FL_SOURCE))
+				continue;
+
+			compose[i]->left = 0;
+			compose[i]->top = 0;
+			compose[i]->width = r->width;
+			compose[i]->height = r->height;
+			rval = ipu_isys_subdev_fmt_propagate(sd, state,
+							     ffmt,
+							     compose[i],
+							     tgt + 1, i,
+							     which);
 			if (rval)
 				goto out_subdev_fmt_propagate;
-			/* n:n case: propagate according to route info */
-		} else if (asd->nsinks == asd->nsources && asd->nsources > 1) {
-			for (i = asd->nsinks; i < sd->entity.num_pads; i++)
-				if (media_entity_has_route(&sd->entity, pad, i))
-					break;
-
-			if (i != sd->entity.num_pads) {
-				compose[i]->left = 0;
-				compose[i]->top = 0;
-				compose[i]->width = r->width;
-				compose[i]->height = r->height;
-				rval = ipu_isys_subdev_fmt_propagate(sd, cfg, ffmt,
-							      compose[i],
-							      tgt + 1, i,
-							      which);
-				if (rval)
-					goto out_subdev_fmt_propagate;
-			}
-			/* n:m case: propagate to all source pad */
-		} else if (asd->nsinks != asd->nsources && asd->nsources > 1 &&
-			   asd->nsources > 1) {
-			for (i = 1; i < sd->entity.num_pads; i++) {
-				if (!(sd->entity.pads[i].flags &
-				      MEDIA_PAD_FL_SOURCE))
-					continue;
-
-				compose[i]->left = 0;
-				compose[i]->top = 0;
-				compose[i]->width = r->width;
-				compose[i]->height = r->height;
-				rval = ipu_isys_subdev_fmt_propagate(sd, cfg,
-							      ffmt,
-							      compose[i],
-							      tgt + 1, i,
-							      which);
-				if (rval)
-					goto out_subdev_fmt_propagate;
-			}
 		}
 		goto out_subdev_fmt_propagate;
 	case IPU_ISYS_SUBDEV_PROP_TGT_SOURCE_COMPOSE:
@@ -344,29 +311,29 @@ int ipu_isys_subdev_fmt_propagate(struct v4l2_subdev *sd,
 		crops[pad]->top = 0;
 		crops[pad]->width = r->width;
 		crops[pad]->height = r->height;
-		rval = ipu_isys_subdev_fmt_propagate(sd, cfg, ffmt,
-					      crops[pad], tgt + 1, pad, which);
+		rval = ipu_isys_subdev_fmt_propagate(sd, state, ffmt,
+						     crops[pad], tgt + 1,
+						     pad, which);
 		goto out_subdev_fmt_propagate;
 	case IPU_ISYS_SUBDEV_PROP_TGT_SOURCE_CROP:{
 			struct v4l2_subdev_format fmt = {
 				.which = which,
 				.pad = pad,
 				.format = {
-					   .width = r->width,
-					   .height = r->height,
-					   /*
-					    * Either use the code from sink pad
-					    * or the current one.
-					    */
-					   .code =
-					   ffmt ? ffmt->code : ffmts[pad]->code,
-					   .field =
-					   ffmt ? ffmt->field : ffmts[pad]->
-					   field,
-					   },
+					.width = r->width,
+					.height = r->height,
+					/*
+					 * Either use the code from sink pad
+					 * or the current one.
+					 */
+					.code = ffmt ? ffmt->code :
+						       ffmts[pad]->code,
+					.field = ffmt ? ffmt->field :
+							ffmts[pad]->field,
+				},
 			};
 
-			asd->set_ffmt(sd, cfg, &fmt);
+			asd->set_ffmt(sd, state, &fmt);
 			goto out_subdev_fmt_propagate;
 		}
 	}
-- 
2.51.0

