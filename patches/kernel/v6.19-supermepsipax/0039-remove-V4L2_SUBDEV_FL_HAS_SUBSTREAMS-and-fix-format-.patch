From 18cd510ad226a76ed2bf2dce0a5dc8ef8788b8f8 Mon Sep 17 00:00:00 2001
From: Tristan <supermepsipax@users.noreply.github.com>
Date: Sun, 8 Feb 2026 09:37:49 +0100
Subject: [PATCH 39/41] remove V4L2_SUBDEV_FL_HAS_SUBSTREAMS and fix format
 enumeration

Remove V4L2_SUBDEV_FL_HAS_SUBSTREAMS from CSI-2 subdevs. In kernel
6.18, the V4L2 core requires stream-aware subdevs to have proper
routing configured, but the IPU4 driver manages streams internally.
The flag caused all set_fmt/get_fmt calls to be rejected with EINVAL.

Fix format enumeration to use the per-device format table (av->pfmts)
instead of the global ipu_isys_pfmts table, and accept
V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE alongside VIDEO_CAPTURE.

Fix five format getter functions to handle MPLANE buffer type,
reading from av->mpix instead of av->pix_fmt.
---
 drivers/media/pci/intel/ipu-isys-csi2.c  |  2 +-
 drivers/media/pci/intel/ipu-isys-video.c | 39 ++++++++++++++++++------
 2 files changed, 30 insertions(+), 11 deletions(-)

diff --git a/drivers/media/pci/intel/ipu-isys-csi2.c b/drivers/media/pci/intel/ipu-isys-csi2.c
index 4651329b346e..39061beec08d 100644
--- a/drivers/media/pci/intel/ipu-isys-csi2.c
+++ b/drivers/media/pci/intel/ipu-isys-csi2.c
@@ -618,7 +618,7 @@ int ipu_isys_csi2_init(struct ipu_isys_csi2 *csi2,
 				    NR_OF_CSI2_STREAMS,
 				    NR_OF_CSI2_SOURCE_PADS,
 				    NR_OF_CSI2_SINK_PADS,
-				    V4L2_SUBDEV_FL_HAS_SUBSTREAMS);
+				    0);
 	if (rval)
 		goto fail;
 
diff --git a/drivers/media/pci/intel/ipu-isys-video.c b/drivers/media/pci/intel/ipu-isys-video.c
index 77c6ba836592..0e35fb632d4f 100644
--- a/drivers/media/pci/intel/ipu-isys-video.c
+++ b/drivers/media/pci/intel/ipu-isys-video.c
@@ -460,16 +460,19 @@ int ipu_isys_vidioc_querycap(struct file *file, void *fh,
 int ipu_isys_vidioc_enum_fmt(struct file *file, void *fh,
 			     struct v4l2_fmtdesc *f)
 {
-	unsigned int i, num_found;
+	struct ipu_isys_video *av = video_drvdata(file);
+	const struct ipu_isys_pixelformat *pfmt;
+	unsigned int num_found;
 
-	for (i = 0, num_found = 0; i < ARRAY_SIZE(ipu_isys_pfmts); i++) {
-		if ((ipu_isys_pfmts[i].is_meta &&
+	for (pfmt = av->pfmts, num_found = 0; pfmt->bpp; pfmt++) {
+		if ((pfmt->is_meta &&
 		     f->type != V4L2_BUF_TYPE_META_CAPTURE) ||
-		    (!ipu_isys_pfmts[i].is_meta &&
-		     f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE))
+		    (!pfmt->is_meta &&
+		     f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&
+		     f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE))
 			continue;
 
-		if (f->mbus_code && f->mbus_code != ipu_isys_pfmts[i].code)
+		if (f->mbus_code && f->mbus_code != pfmt->code)
 			continue;
 
 		if (num_found < f->index) {
@@ -478,7 +481,7 @@ int ipu_isys_vidioc_enum_fmt(struct file *file, void *fh,
 		}
 
 		f->flags = 0;
-		f->pixelformat = ipu_isys_pfmts[i].pixelformat;
+		f->pixelformat = pfmt->pixelformat;
 
 		return 0;
 	}
@@ -489,13 +492,14 @@ int ipu_isys_vidioc_enum_fmt(struct file *file, void *fh,
 static int ipu_isys_vidioc_enum_framesizes(struct file *file, void *fh,
 					    struct v4l2_frmsizeenum *fsize)
 {
-	unsigned int i;
+	struct ipu_isys_video *av = video_drvdata(file);
+	const struct ipu_isys_pixelformat *pfmt;
 
 	if (fsize->index > 0)
 		return -EINVAL;
 
-	for (i = 0; i < ARRAY_SIZE(ipu_isys_pfmts); i++) {
-		if (fsize->pixel_format != ipu_isys_pfmts[i].pixelformat)
+	for (pfmt = av->pfmts; pfmt->bpp; pfmt++) {
+		if (fsize->pixel_format != pfmt->pixelformat)
 			continue;
 
 		fsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;
@@ -2301,6 +2305,9 @@ u32 ipu_isys_get_format(struct ipu_isys_video *av)
 	if (av->aq.vbq.type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
 		return av->pix_fmt.pixelformat;
 
+	if (av->aq.vbq.type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
+		return av->mpix.pixelformat;
+
 	if (av->aq.vbq.type == V4L2_BUF_TYPE_META_CAPTURE)
 		return av->meta_fmt.dataformat;
 
@@ -2312,6 +2319,9 @@ u32 ipu_isys_get_data_size(struct ipu_isys_video *av)
 	if (av->aq.vbq.type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
 		return av->pix_fmt.sizeimage;
 
+	if (av->aq.vbq.type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
+		return av->mpix.plane_fmt[0].sizeimage;
+
 	if (av->aq.vbq.type == V4L2_BUF_TYPE_META_CAPTURE)
 		return av->meta_fmt.buffersize;
 
@@ -2323,6 +2333,9 @@ u32 ipu_isys_get_bytes_per_line(struct ipu_isys_video *av)
 	if (av->aq.vbq.type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
 		return av->pix_fmt.bytesperline;
 
+	if (av->aq.vbq.type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
+		return av->mpix.plane_fmt[0].bytesperline;
+
 	if (av->aq.vbq.type == V4L2_BUF_TYPE_META_CAPTURE)
 		return av->meta_fmt.bytesperline;
 
@@ -2334,6 +2347,9 @@ u32 ipu_isys_get_frame_width(struct ipu_isys_video *av)
 	if (av->aq.vbq.type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
 		return av->pix_fmt.width;
 
+	if (av->aq.vbq.type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
+		return av->mpix.width;
+
 	if (av->aq.vbq.type == V4L2_BUF_TYPE_META_CAPTURE)
 		return av->meta_fmt.width;
 
@@ -2345,6 +2361,9 @@ u32 ipu_isys_get_frame_height(struct ipu_isys_video *av)
 	if (av->aq.vbq.type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
 		return av->pix_fmt.height;
 
+	if (av->aq.vbq.type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
+		return av->mpix.height;
+
 	if (av->aq.vbq.type == V4L2_BUF_TYPE_META_CAPTURE)
 		return av->meta_fmt.height;
 
-- 
2.51.0

