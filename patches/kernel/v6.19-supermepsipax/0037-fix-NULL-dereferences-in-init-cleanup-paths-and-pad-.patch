From 3798578de0de822ff05c3dbd3483ecb102062aca Mon Sep 17 00:00:00 2001
From: Tristan <supermepsipax@users.noreply.github.com>
Date: Sun, 8 Feb 2026 09:32:03 +0100
Subject: [PATCH 37/41] fix NULL dereferences in init/cleanup paths and pad
 flag validation

Kernel 6.18 changes that cause runtime crashes:
- media_entity_pads_init() now requires SINK/SOURCE flags on each pad
- vb2_queue_release() crashes on uninitialized queues (NULL done_wq)
- Cleanup functions dereference NULL on partially-initialized subdevs
- v4l2_subdev_state_get_format/crop/compose returns NULL for
  stream-aware subdevs without routing, causing NULL derefs

Fix by:
- Setting default pad direction flags before media_entity_pads_init()
- Guarding queue/video/subdev cleanup against uninitialized state
- Falling back to ACTIVE format when TRY state accessors return NULL
- Adding NULL checks in ipu_isys_subdev_open for state accessors
- Adding init debug logging to ipu_isys_csi2_init
---
 .../media/pci/intel/ipu-isys-csi2-be-soc.c    |  3 ++
 drivers/media/pci/intel/ipu-isys-csi2-be.c    |  3 ++
 drivers/media/pci/intel/ipu-isys-csi2.c       | 10 +++++
 drivers/media/pci/intel/ipu-isys-queue.c      |  4 ++
 drivers/media/pci/intel/ipu-isys-subdev.c     | 41 +++++++++++++++----
 drivers/media/pci/intel/ipu-isys-tpg.c        |  3 ++
 drivers/media/pci/intel/ipu-isys-video.c      |  4 ++
 drivers/media/pci/intel/ipu-isys.c            | 10 +++--
 drivers/media/pci/intel/ipu4/ipu4-isys-isa.c  |  3 ++
 9 files changed, 70 insertions(+), 11 deletions(-)

diff --git a/drivers/media/pci/intel/ipu-isys-csi2-be-soc.c b/drivers/media/pci/intel/ipu-isys-csi2-be-soc.c
index 3fc1221781e5..4f3f5fd11194 100644
--- a/drivers/media/pci/intel/ipu-isys-csi2-be-soc.c
+++ b/drivers/media/pci/intel/ipu-isys-csi2-be-soc.c
@@ -222,6 +222,9 @@ void ipu_isys_csi2_be_soc_cleanup(struct ipu_isys_csi2_be_soc *csi2_be_soc)
 {
 	int i;
 
+	if (!csi2_be_soc->asd.sd.v4l2_dev)
+		return;
+
 	v4l2_device_unregister_subdev(&csi2_be_soc->asd.sd);
 	ipu_isys_subdev_cleanup(&csi2_be_soc->asd);
 	for (i = 0; i < NR_OF_CSI2_BE_SOC_STREAMS; i++)
diff --git a/drivers/media/pci/intel/ipu-isys-csi2-be.c b/drivers/media/pci/intel/ipu-isys-csi2-be.c
index bbf1b3ff5f9f..2c1fc7123ad5 100644
--- a/drivers/media/pci/intel/ipu-isys-csi2-be.c
+++ b/drivers/media/pci/intel/ipu-isys-csi2-be.c
@@ -206,6 +206,9 @@ static void csi2_be_set_ffmt(struct v4l2_subdev *sd,
 
 void ipu_isys_csi2_be_cleanup(struct ipu_isys_csi2_be *csi2_be)
 {
+	if (!csi2_be->asd.sd.v4l2_dev)
+		return;
+
 	v4l2_device_unregister_subdev(&csi2_be->asd.sd);
 	ipu_isys_subdev_cleanup(&csi2_be->asd);
 	ipu_isys_video_cleanup(&csi2_be->av);
diff --git a/drivers/media/pci/intel/ipu-isys-csi2.c b/drivers/media/pci/intel/ipu-isys-csi2.c
index 67bcc112aa3c..4651329b346e 100644
--- a/drivers/media/pci/intel/ipu-isys-csi2.c
+++ b/drivers/media/pci/intel/ipu-isys-csi2.c
@@ -611,6 +611,8 @@ int ipu_isys_csi2_init(struct ipu_isys_csi2 *csi2,
 	csi2->remote_streams = 1;
 	csi2->stream_count = 0;
 
+	dev_info(&isys->adev->dev, "CSI-2 %u: calling ipu_isys_subdev_init\n",
+		index);
 	rval = ipu_isys_subdev_init(&csi2->asd, &csi2_sd_ops, 0,
 				    NR_OF_CSI2_PADS,
 				    NR_OF_CSI2_STREAMS,
@@ -647,6 +649,8 @@ int ipu_isys_csi2_init(struct ipu_isys_csi2 *csi2,
 	v4l2_set_subdevdata(&csi2->asd.sd, &csi2->asd);
 
 	mutex_lock(&csi2->asd.mutex);
+	dev_info(&isys->adev->dev, "CSI-2 %u: registering v4l2 subdev\n",
+		index);
 	rval = v4l2_device_register_subdev(&isys->v4l2_dev, &csi2->asd.sd);
 	if (rval) {
 		mutex_unlock(&csi2->asd.mutex);
@@ -698,6 +702,9 @@ int ipu_isys_csi2_init(struct ipu_isys_csi2 *csi2,
 		csi2->av[i].aq.vbq.buf_struct_size =
 		    sizeof(struct ipu_isys_video_buffer);
 
+		dev_info(&isys->adev->dev,
+			"CSI-2 %u: calling ipu_isys_video_init for source pad %d\n",
+			index, i);
 		rval = ipu_isys_video_init(&csi2->av[i],
 					   &csi2->asd.sd.entity,
 					   CSI2_PAD_SOURCE(i),
@@ -728,6 +735,9 @@ int ipu_isys_csi2_init(struct ipu_isys_csi2 *csi2,
 	csi2->av_meta.aq.vbq.buf_struct_size =
 	    sizeof(struct ipu_isys_video_buffer);
 
+	dev_info(&isys->adev->dev,
+		"CSI-2 %u: calling ipu_isys_video_init for meta pad\n",
+		index);
 	rval = ipu_isys_video_init(&csi2->av_meta, &csi2->asd.sd.entity,
 				   CSI2_PAD_META, MEDIA_PAD_FL_SINK, 0);
 	if (rval) {
diff --git a/drivers/media/pci/intel/ipu-isys-queue.c b/drivers/media/pci/intel/ipu-isys-queue.c
index d95bee52fcb1..e095a6b62ce5 100644
--- a/drivers/media/pci/intel/ipu-isys-queue.c
+++ b/drivers/media/pci/intel/ipu-isys-queue.c
@@ -1415,5 +1415,9 @@ int ipu_isys_queue_init(struct ipu_isys_queue *aq)
 
 void ipu_isys_queue_cleanup(struct ipu_isys_queue *aq)
 {
+	/* Guard against cleanup of never-initialized queue */
+	if (!aq->vbq.ops)
+		return;
+
 	vb2_queue_release(&aq->vbq);
 }
diff --git a/drivers/media/pci/intel/ipu-isys-subdev.c b/drivers/media/pci/intel/ipu-isys-subdev.c
index ca4535398713..34c32459e4be 100644
--- a/drivers/media/pci/intel/ipu-isys-subdev.c
+++ b/drivers/media/pci/intel/ipu-isys-subdev.c
@@ -155,10 +155,20 @@ struct v4l2_mbus_framefmt *__ipu_isys_get_ffmt(struct v4l2_subdev *sd,
 {
 	struct ipu_isys_subdev *asd = to_ipu_isys_subdev(sd);
 
+	struct v4l2_mbus_framefmt *ffmt;
+
 	if (which == V4L2_SUBDEV_FORMAT_ACTIVE)
 		return &asd->ffmt[pad][stream];
-	else
-		return v4l2_subdev_state_get_format(cfg, pad);
+
+	/*
+	 * For stream-aware subdevs without routing configured,
+	 * v4l2_subdev_state_get_format() returns NULL in kernel 6.18+.
+	 * Fall back to the ACTIVE format in that case.
+	 */
+	ffmt = v4l2_subdev_state_get_format(cfg, pad);
+	if (!ffmt)
+		ffmt = &asd->ffmt[pad][stream];
+	return ffmt;
 }
 
 struct v4l2_rect *__ipu_isys_get_selection(struct v4l2_subdev *sd,
@@ -176,11 +186,15 @@ struct v4l2_rect *__ipu_isys_get_selection(struct v4l2_subdev *sd,
 			return &asd->compose[pad];
 		}
 	} else {
+		struct v4l2_rect *rect;
+
 		switch (target) {
 		case V4L2_SEL_TGT_CROP:
-			return v4l2_subdev_state_get_crop(cfg, pad);
+			rect = v4l2_subdev_state_get_crop(cfg, pad);
+			return rect ? rect : &asd->crop[pad];
 		case V4L2_SEL_TGT_COMPOSE:
-			return v4l2_subdev_state_get_compose(cfg, pad);
+			rect = v4l2_subdev_state_get_compose(cfg, pad);
+			return rect ? rect : &asd->compose[pad];
 		}
 	}
 	WARN_ON(1);
@@ -880,9 +894,12 @@ int ipu_isys_subdev_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
 		struct v4l2_rect *try_compose =
 			v4l2_subdev_state_get_compose(fh->state, i);
 
-		*try_fmt = asd->ffmt[i][0];
-		*try_crop = asd->crop[i];
-		*try_compose = asd->compose[i];
+		if (try_fmt)
+			*try_fmt = asd->ffmt[i][0];
+		if (try_crop)
+			*try_crop = asd->crop[i];
+		if (try_compose)
+			*try_compose = asd->compose[i];
 	}
 
 	mutex_unlock(&asd->mutex);
@@ -958,6 +975,16 @@ int ipu_isys_subdev_init(struct ipu_isys_subdev *asd,
 			return -ENOMEM;
 	}
 
+	/*
+	 * Set default pad direction flags before media_entity_pads_init().
+	 * Kernel 6.18+ validates that each pad has exactly one of SINK/SOURCE.
+	 * Callers may override these flags after ipu_isys_subdev_init returns.
+	 */
+	for (i = 0; i < num_sink; i++)
+		asd->pad[i].flags = MEDIA_PAD_FL_SINK;
+	for (i = num_sink; i < num_pads; i++)
+		asd->pad[i].flags = MEDIA_PAD_FL_SOURCE;
+
 	rval = media_entity_pads_init(&asd->sd.entity, num_pads, asd->pad);
 	if (rval)
 		goto out_mutex_destroy;
diff --git a/drivers/media/pci/intel/ipu-isys-tpg.c b/drivers/media/pci/intel/ipu-isys-tpg.c
index 59151f3954ab..10aeec19d09c 100644
--- a/drivers/media/pci/intel/ipu-isys-tpg.c
+++ b/drivers/media/pci/intel/ipu-isys-tpg.c
@@ -251,6 +251,9 @@ static struct media_entity_operations tpg_entity_ops = {
 
 void ipu_isys_tpg_cleanup(struct ipu_isys_tpg *tpg)
 {
+	if (!tpg->asd.sd.v4l2_dev)
+		return;
+
 	v4l2_device_unregister_subdev(&tpg->asd.sd);
 	ipu_isys_subdev_cleanup(&tpg->asd);
 	ipu_isys_video_cleanup(&tpg->av);
diff --git a/drivers/media/pci/intel/ipu-isys-video.c b/drivers/media/pci/intel/ipu-isys-video.c
index 2b75f093f57d..77c6ba836592 100644
--- a/drivers/media/pci/intel/ipu-isys-video.c
+++ b/drivers/media/pci/intel/ipu-isys-video.c
@@ -2286,6 +2286,10 @@ int ipu_isys_video_init(struct ipu_isys_video *av,
 
 void ipu_isys_video_cleanup(struct ipu_isys_video *av)
 {
+	/* Guard against cleanup of never-initialized video node */
+	if (!av->aq.vbq.ops)
+		return;
+
 	video_unregister_device(&av->vdev);
 	media_entity_cleanup(&av->vdev.entity);
 	mutex_destroy(&av->mutex);
diff --git a/drivers/media/pci/intel/ipu-isys.c b/drivers/media/pci/intel/ipu-isys.c
index d14be04414bf..757a1fafdd7f 100644
--- a/drivers/media/pci/intel/ipu-isys.c
+++ b/drivers/media/pci/intel/ipu-isys.c
@@ -215,11 +215,13 @@ static void isys_unregister_subdevices(struct ipu_isys *isys)
 
 	ipu_isys_isa_cleanup(&isys->isa);
 
-	for (i = 0; i < tpg->ntpgs; i++)
-		ipu_isys_tpg_cleanup(&isys->tpg[i]);
+	if (isys->tpg)
+		for (i = 0; i < tpg->ntpgs; i++)
+			ipu_isys_tpg_cleanup(&isys->tpg[i]);
 
-	for (i = 0; i < csi2->nports; i++)
-		ipu_isys_csi2_cleanup(&isys->csi2[i]);
+	if (isys->csi2)
+		for (i = 0; i < csi2->nports; i++)
+			ipu_isys_csi2_cleanup(&isys->csi2[i]);
 }
 
 static int isys_register_subdevices(struct ipu_isys *isys)
diff --git a/drivers/media/pci/intel/ipu4/ipu4-isys-isa.c b/drivers/media/pci/intel/ipu4/ipu4-isys-isa.c
index 4ac6545ecc73..a9652b66c1ae 100644
--- a/drivers/media/pci/intel/ipu4/ipu4-isys-isa.c
+++ b/drivers/media/pci/intel/ipu4/ipu4-isys-isa.c
@@ -231,6 +231,9 @@ static struct media_entity_operations isa_entity_ops = {
 
 void ipu_isys_isa_cleanup(struct ipu_isys_isa *isa)
 {
+	if (!isa->asd.sd.v4l2_dev)
+		return;
+
 	v4l2_device_unregister_subdev(&isa->asd.sd);
 	ipu_isys_subdev_cleanup(&isa->asd);
 	ipu_isys_video_cleanup(&isa->av_scaled);
-- 
2.51.0

