From f9503ab072f28abc66ceeee384bbeeb5f33ba734 Mon Sep 17 00:00:00 2001
From: ruslanbay <67730802+ruslanbay@users.noreply.github.com>
Date: Tue, 30 Dec 2025 14:34:22 +0100
Subject: [PATCH 05/16] port drivers/media/mc from
 https://github.com/intel/linux-intel-lts/tree/lts-v5.15.195-android_t-251103T063840Z/drivers/media/

---
 drivers/media/mc/mc-device.c      | 20 +++++++
 drivers/media/mc/mc-devnode.c     | 18 +++---
 drivers/media/mc/mc-entity.c      | 99 +++++++++++++++++++++----------
 drivers/media/v4l2-core/v4l2-mc.c | 16 +++--
 include/media/media-devnode.h     | 18 +++++-
 include/media/media-entity.h      | 23 ++++++-
 6 files changed, 147 insertions(+), 47 deletions(-)

diff --git a/drivers/media/mc/mc-device.c b/drivers/media/mc/mc-device.c
index cf5e459b1d96..106ce313ae2b 100644
--- a/drivers/media/mc/mc-device.c
+++ b/drivers/media/mc/mc-device.c
@@ -25,6 +25,14 @@
 #include <media/media-request.h>
 
 #ifdef CONFIG_MEDIA_CONTROLLER
+struct media_device_fh {
+       struct media_devnode_fh fh;
+};
+
+static inline struct media_device_fh *media_device_fh(struct file *filp)
+{
+       return container_of(filp->private_data, struct media_device_fh, fh);
+}
 
 /*
  * Legacy defines from linux/media.h. This is the only place we need this
@@ -47,11 +55,23 @@ static inline void __user *media_get_uptr(__u64 arg)
 
 static int media_device_open(struct file *filp)
 {
+	struct media_device_fh *fh;
+
+	fh = kzalloc(sizeof(*fh), GFP_KERNEL);
+	if (!fh)
+		return -ENOMEM;
+
+	filp->private_data = &fh->fh;
+
 	return 0;
 }
 
 static int media_device_close(struct file *filp)
 {
+	struct media_device_fh *fh = media_device_fh(filp);
+
+	kfree(fh);
+
 	return 0;
 }
 
diff --git a/drivers/media/mc/mc-devnode.c b/drivers/media/mc/mc-devnode.c
index f8257aa5fc58..d0dd5b6d93b8 100644
--- a/drivers/media/mc/mc-devnode.c
+++ b/drivers/media/mc/mc-devnode.c
@@ -136,6 +136,7 @@ static long media_compat_ioctl(struct file *filp, unsigned int cmd,
 /* Override for the open function */
 static int media_open(struct inode *inode, struct file *filp)
 {
+	struct media_devnode_fh *fh;
 	struct media_devnode *devnode;
 	int ret;
 
@@ -157,17 +158,16 @@ static int media_open(struct inode *inode, struct file *filp)
 	get_device(&devnode->dev);
 	mutex_unlock(&media_devnode_lock);
 
-	filp->private_data = devnode;
-
-	if (devnode->fops->open) {
-		ret = devnode->fops->open(filp);
-		if (ret) {
-			put_device(&devnode->dev);
-			filp->private_data = NULL;
-			return ret;
-		}
+	ret = devnode->fops->open(filp);
+	if (ret) {
+		put_device(&devnode->dev);
+		filp->private_data = NULL;
+		return ret;
 	}
 
+	fh = filp->private_data;
+	fh->devnode = devnode;
+
 	return 0;
 }
 
diff --git a/drivers/media/mc/mc-entity.c b/drivers/media/mc/mc-entity.c
index f40f41977142..58d8946153cf 100644
--- a/drivers/media/mc/mc-entity.c
+++ b/drivers/media/mc/mc-entity.c
@@ -228,18 +228,38 @@ EXPORT_SYMBOL_GPL(media_entity_pads_init);
  * Graph traversal
  */
 
-static struct media_entity *
-media_entity_other(struct media_entity *entity, struct media_link *link)
+/**
+ * media_entity_has_route - Check if two entity pads are connected internally
+ * @entity: The entity
+ * @pad0: The first pad index
+ * @pad1: The second pad index
+ *
+ * This function can be used to check whether two pads of an entity are
+ * connected internally in the entity.
+ *
+ * The caller must hold entity->source->parent->mutex.
+ *
+ * Return: true if the pads are connected internally and false otherwise.
+ */
+bool media_entity_has_route(struct media_entity *entity, unsigned int pad0,
+			    unsigned int pad1)
 {
-	if (link->source->entity == entity)
-		return link->sink->entity;
-	else
-		return link->source->entity;
+	if (pad0 >= entity->num_pads || pad1 >= entity->num_pads)
+		return false;
+
+	if (pad0 == pad1)
+		return true;
+
+	if (!entity->ops || !entity->ops->has_route)
+		return true;
+
+	return entity->ops->has_route(entity, pad0, pad1, NULL);
 }
+EXPORT_SYMBOL_GPL(media_entity_has_route);
 
 /* push an entity to traversal stack */
 static void stack_push(struct media_graph *graph,
-		       struct media_entity *entity)
+		       struct media_entity *entity, int pad, int stream)
 {
 	if (graph->top == MEDIA_ENTITY_ENUM_MAX_DEPTH - 1) {
 		WARN_ON(1);
@@ -247,7 +267,9 @@ static void stack_push(struct media_graph *graph,
 	}
 	graph->top++;
 	graph->stack[graph->top].link = entity->links.next;
+	graph->stack[graph->top].pad = pad;
 	graph->stack[graph->top].entity = entity;
+	graph->stack[graph->top].stream = stream;
 }
 
 static struct media_entity *stack_pop(struct media_graph *graph)
@@ -261,6 +283,8 @@ static struct media_entity *stack_pop(struct media_graph *graph)
 }
 
 #define link_top(en)	((en)->stack[(en)->top].link)
+#define pad_top(en)	((en)->stack[(en)->top].pad)
+#define stream_top(en)	((en)->stack[(en)->top].stream)
 #define stack_top(en)	((en)->stack[(en)->top].entity)
 
 /**
@@ -292,16 +316,16 @@ void media_graph_walk_cleanup(struct media_graph *graph)
 EXPORT_SYMBOL_GPL(media_graph_walk_cleanup);
 
 void media_graph_walk_start(struct media_graph *graph,
-			    struct media_entity *entity)
+			    struct media_pad *pad)
 {
 	media_entity_enum_zero(&graph->ent_enum);
-	media_entity_enum_set(&graph->ent_enum, entity);
+	media_entity_enum_set(&graph->ent_enum, pad->entity);
 
 	graph->top = 0;
 	graph->stack[graph->top].entity = NULL;
-	stack_push(graph, entity);
-	dev_dbg(entity->graph_obj.mdev->dev,
-		"begin graph walk at '%s'\n", entity->name);
+	stack_push(graph, pad->entity, pad->index, -1);
+	dev_dbg(pad->entity->graph_obj.mdev->dev,
+		"begin graph walk at '%s'\n", pad->entity->name);
 }
 EXPORT_SYMBOL_GPL(media_graph_walk_start);
 
@@ -309,7 +333,11 @@ static void media_graph_walk_iter(struct media_graph *graph)
 {
 	struct media_entity *entity = stack_top(graph);
 	struct media_link *link;
+	unsigned int from_pad = pad_top(graph);
 	struct media_entity *next;
+	struct media_pad *remote;
+	struct media_pad *local;
+	int stream = stream_top(graph);
 
 	link = list_entry(link_top(graph), typeof(*link), list);
 
@@ -323,8 +351,31 @@ static void media_graph_walk_iter(struct media_graph *graph)
 		return;
 	}
 
-	/* Get the entity at the other end of the link. */
-	next = media_entity_other(entity, link);
+	/*
+	 * Get the local pad, the remote pad and the entity at the other
+	 * end of the link.
+	 */
+	if (link->source->entity == entity) {
+		remote = link->sink;
+		local = link->source;
+	} else {
+		remote = link->source;
+		local = link->sink;
+	}
+
+	next = remote->entity;
+
+	/*
+	 * Are the local pad and the pad we came from connected
+	 * internally in the entity ?
+	 */
+	if (entity->ops && entity->ops->has_route) {
+		if (!entity->ops->has_route(entity, from_pad,
+			local->index, &stream)) {
+			link_top(graph) = link_top(graph)->next;
+			return;
+		}
+	}
 
 	/* Has the entity already been visited? */
 	if (media_entity_enum_test_and_set(&graph->ent_enum, next)) {
@@ -337,7 +388,7 @@ static void media_graph_walk_iter(struct media_graph *graph)
 
 	/* Push the new entity to stack and start over. */
 	link_top(graph) = link_top(graph)->next;
-	stack_push(graph, next);
+	stack_push(graph, next, remote->index, stream);
 	dev_dbg(entity->graph_obj.mdev->dev, "walk: pushing '%s' on stack\n",
 		next->name);
 	lockdep_assert_held(&entity->graph_obj.mdev->graph_mutex);
@@ -420,7 +471,7 @@ __must_check int __media_pipeline_start(struct media_entity *entity,
 			goto error_graph_walk_start;
 	}
 
-	media_graph_walk_start(&pipe->graph, entity);
+	media_graph_walk_start(graph, &entity->pads[0]);
 
 	while ((entity = media_graph_walk_next(graph))) {
 		DECLARE_BITMAP(active, MEDIA_ENTITY_MAX_PADS);
@@ -428,20 +479,8 @@ __must_check int __media_pipeline_start(struct media_entity *entity,
 
 		entity->stream_count++;
 
-		if (entity->pipe && entity->pipe != pipe) {
-			pr_err("Pipe active for %s. Can't start for %s\n",
-				entity->name,
-				entity_err->name);
-			ret = -EBUSY;
-			goto error;
-		}
-
 		entity->pipe = pipe;
 
-		/* Already streaming --- no need to check. */
-		if (entity->stream_count > 1)
-			continue;
-
 		if (!entity->ops || !entity->ops->link_validate)
 			continue;
 
@@ -504,7 +543,7 @@ __must_check int __media_pipeline_start(struct media_entity *entity,
 	 * Link validation on graph failed. We revert what we did and
 	 * return the error.
 	 */
-	media_graph_walk_start(graph, entity_err);
+	media_graph_walk_start(graph, &entity_err->pads[0]);
 
 	while ((entity_err = media_graph_walk_next(graph))) {
 		/* Sanity check for negative stream_count */
@@ -555,7 +594,7 @@ void __media_pipeline_stop(struct media_entity *entity)
 	if (WARN_ON(!pipe))
 		return;
 
-	media_graph_walk_start(graph, entity);
+	media_graph_walk_start(graph, &entity->pads[0]);
 
 	while ((entity = media_graph_walk_next(graph))) {
 		/* Sanity check for negative stream_count */
diff --git a/drivers/media/v4l2-core/v4l2-mc.c b/drivers/media/v4l2-core/v4l2-mc.c
index 541c99c24923..4c366b691223 100644
--- a/drivers/media/v4l2-core/v4l2-mc.c
+++ b/drivers/media/v4l2-core/v4l2-mc.c
@@ -431,12 +431,13 @@ EXPORT_SYMBOL_GPL(v4l2_create_fwnode_links);
  *
  * Return the total number of users of all video device nodes in the pipeline.
  */
-static int pipeline_pm_use_count(struct media_entity *entity,
+static int pipeline_pm_use_count(struct media_pad *pad,
 	struct media_graph *graph)
 {
+	struct media_entity *entity = pad->entity;
 	int use = 0;
 
-	media_graph_walk_start(graph, entity);
+	media_graph_walk_start(graph, pad);
 
 	while ((entity = media_graph_walk_next(graph))) {
 		if (is_media_entity_v4l2_video_device(entity))
@@ -499,7 +500,7 @@ static int pipeline_pm_power(struct media_entity *entity, int change,
 	if (!change)
 		return 0;
 
-	media_graph_walk_start(graph, entity);
+	media_graph_walk_start(graph, &entity->pads[0]);
 
 	while (!ret && (entity = media_graph_walk_next(graph)))
 		if (is_media_entity_v4l2_subdev(entity))
@@ -508,7 +509,7 @@ static int pipeline_pm_power(struct media_entity *entity, int change,
 	if (!ret)
 		return ret;
 
-	media_graph_walk_start(graph, first);
+	media_graph_walk_start(graph, &first->pads[0]);
 
 	while ((first = media_graph_walk_next(graph))
 	       && first != entity)
@@ -563,14 +564,17 @@ int v4l2_pipeline_link_notify(struct media_link *link, u32 flags,
 	int sink_use;
 	int ret = 0;
 
-	source_use = pipeline_pm_use_count(source, graph);
-	sink_use = pipeline_pm_use_count(sink, graph);
+	source_use = pipeline_pm_use_count(link->source, graph);
+	sink_use = pipeline_pm_use_count(link->sink, graph);
 
 	if (notification == MEDIA_DEV_NOTIFY_POST_LINK_CH &&
 	    !(flags & MEDIA_LNK_FL_ENABLED)) {
 		/* Powering off entities is assumed to never fail. */
 		pipeline_pm_power(source, -sink_use, graph);
 		pipeline_pm_power(sink, -source_use, graph);
+
+		source->use_count = 0;
+		sink->use_count = 0;
 		return 0;
 	}
 
diff --git a/include/media/media-devnode.h b/include/media/media-devnode.h
index d27c1c646c28..6c2e253dde49 100644
--- a/include/media/media-devnode.h
+++ b/include/media/media-devnode.h
@@ -55,6 +55,20 @@ struct media_file_operations {
 	int (*release) (struct file *);
 };
 
+/**
+ * struct media_devnode_fh - Media device node file handle
+ * @devnode:	pointer to the media device node
+ *
+ * This structure serves as a base for per-file-handle data storage. Media
+ * device node users embed media_devnode_fh in their custom file handle data
+ * structures and store the media_devnode_fh in the file private_data in order
+ * to let the media device node core locate the media_devnode corresponding to a
+ * file handle.
+ */
+struct media_devnode_fh {
+	struct media_devnode *devnode;
+};
+
 /**
  * struct media_devnode - Media device node
  * @media_dev:	pointer to struct &media_device
@@ -146,7 +160,9 @@ void media_devnode_unregister(struct media_devnode *devnode);
  */
 static inline struct media_devnode *media_devnode_data(struct file *filp)
 {
-	return filp->private_data;
+	struct media_devnode_fh *fh = filp->private_data;
+
+	return fh->devnode;
 }
 
 /**
diff --git a/include/media/media-entity.h b/include/media/media-entity.h
index 09737b47881f..39106e5dac19 100644
--- a/include/media/media-entity.h
+++ b/include/media/media-entity.h
@@ -89,6 +89,8 @@ struct media_graph {
 	struct {
 		struct media_entity *entity;
 		struct list_head *link;
+		int stream;
+		int pad;
 	} stack[MEDIA_ENTITY_ENUM_MAX_DEPTH];
 
 	struct media_entity_enum ent_enum;
@@ -205,6 +207,9 @@ struct media_pad {
  * @link_validate:	Return whether a link is valid from the entity point of
  *			view. The media_pipeline_start() function
  *			validates all links by calling this operation. Optional.
+ * @has_route:		Return whether a route exists inside the entity between
+ *			two given pads. Optional. If the operation isn't
+ *			implemented all pads will be considered as connected.
  *
  * .. note::
  *
@@ -218,6 +223,8 @@ struct media_entity_operations {
 			  const struct media_pad *local,
 			  const struct media_pad *remote, u32 flags);
 	int (*link_validate)(struct media_link *link);
+	bool (*has_route)(struct media_entity *entity, unsigned int pad0,
+			  unsigned int pad1, int *stream);
 };
 
 /**
@@ -901,6 +908,20 @@ __must_check int media_graph_walk_init(
  */
 void media_graph_walk_cleanup(struct media_graph *graph);
 
+/**
+ * media_entity_put - Release the reference to the parent module
+ *
+ * @entity: The entity
+ *
+ * Release the reference count acquired by media_entity_get().
+ *
+ * The function will return immediately if @entity is %NULL.
+ */
+void media_entity_put(struct media_entity *entity);
+
+bool media_entity_has_route(struct media_entity *entity, unsigned int sink,
+			unsigned int source);
+
 /**
  * media_graph_walk_start - Start walking the media graph at a
  *	given entity
@@ -917,7 +938,7 @@ void media_graph_walk_cleanup(struct media_graph *graph);
  * using media_graph_walk_cleanup().
  */
 void media_graph_walk_start(struct media_graph *graph,
-			    struct media_entity *entity);
+			    struct media_pad *pad);
 
 /**
  * media_graph_walk_next - Get the next entity in the graph
-- 
2.43.0

